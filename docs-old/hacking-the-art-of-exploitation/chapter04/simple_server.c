#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "../chapter02/hacking.h"

#define PORT 7890 // The port users will be connecting to

// gcc -g simple_server.c -o simple_server.out
int main(void) {
  int sockfd, new_sockfd; // Listen on sock_fd, new connection on new_sockfd
  struct sockaddr_in host_addr, client_addr; // My address information
  socklen_t sin_size;
  int recv_length=1, yes=1;
  char buffer[1024];

  printf("Start server on port %d\n", PORT);

  // setup TCP/IP socket: PF_INET for IPv4 and SOCK_STREAM for stream socket
  // 0 (last argument): there is only one protocol in the PF_INET protocol family
  // returns a socket file descriptor
  if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
    fatal("in socket");

  // SO_REUSEADDR allows to reuse a given address for binding
  // if a socket isn't closed properly, it may appear to be in use
  // since SO_REUSEADDR is a socket-level option, the level is set to SOL_SOCKET
  if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
    fatal("setting socket option SO_REUSEADDR");

  host_addr.sin_family = AF_INET; // Host byte order
  host_addr.sin_port = htons(PORT); // Short, network byte order
  host_addr.sin_addr.s_addr = 0; // Automatically fill with my IP.
  memset(&(host_addr.sin_zero), '\0', 8); // Zero the rest of the struct.

  if (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)
    fatal("binding to socket");
  // listen() function places all incoming connections into a backlog queue until an accept() call accepts the connections
  if (listen(sockfd, 5) == -1)
    fatal("listening on socket");

  while(1) { // Accept loop.
    sin_size = sizeof(struct sockaddr_in);
    new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);
    if (new_sockfd == -1)
      fatal("accepting connection");

    printf("server: got connection from %s port %d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
    send(new_sockfd, "Hello, world!\n", 13, 0);
    recv_length = recv(new_sockfd, &buffer, 1024, 0);
    while(recv_length > 0) {
      printf("RECV: %d bytes\n", recv_length);
      dump(buffer, recv_length);
      recv_length = recv(new_sockfd, &buffer, 1024, 0);
    }
    close(new_sockfd);
  }
  return 0;
}

/*

docker inspect ubuntu | jq -r '.[].NetworkSettings.Networks.bridge.IPAddress'
172.17.0.2

OUTPUT

# from container
./simple_server.out 
Start server on port 7890
server: got connection from 172.17.0.1 port 53888
RECV: 6 bytes
68 65 6c 6c 6f 0a           | hello.
server: got connection from 172.17.0.1 port 53890
RECV: 6 bytes
74 65 73 74 0d 0a           | test..

# from host
echo "hello" | nc 172.17.0.2 7890
Hello, world!

telnet 172.17.0.2 7890
Trying 172.17.0.2...
Connected to 172.17.0.2.
Escape character is '^]'.
Hello, world!test

echo $(perl -e 'print "A"x2048') | nc 172.17.0.2 7890

*/
