#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>

void usage(char *prog_name, char *filename) {
  printf("Usage: %s <data to add to %s>\n", prog_name, filename);
  exit(0);
}

void fatal(char *); // A function for fatal errors
void *ec_malloc(unsigned int); // An error-checked malloc() wrapper

// gcc -g simplenote.c -o simplenote.out
int main(int argc, char *argv[]) {
  int fd; // file descriptor
  char *buffer, *datafile;

  buffer = (char *) ec_malloc(100);
  datafile = (char *) ec_malloc(20);
  strcpy(datafile, "/tmp/notes");

  if (argc < 2) // If there aren't command-line arguments,
    usage(argv[0], datafile); // display usage message and exit.

  strcpy(buffer, argv[1]); // Copy into buffer.
  printf("[DEBUG] buffer @ %p: \'%s\'\n", buffer, buffer);
  printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);

  strncat(buffer, "\n", 1); // Add a newline on the end.

  // Opening file
  fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
  if (fd == -1)
    fatal("in main() while opening file");

  printf("[DEBUG] file descriptor is %d\n", fd);

  // Writing data
  if (write(fd, buffer, strlen(buffer)) == -1)
    fatal("in main() while writing buffer to file");

  // Closing file
  if (close(fd) == -1)
    fatal("in main() while closing file");

  printf("Note has been saved.\n");
  free(buffer);
  free(datafile);
}

// A function to display an error message and then exit
void fatal(char *message) {
  char error_message[100];

  strcpy(error_message, "[!!] Fatal Error ");
  strncat(error_message, message, 83);
  perror(error_message); // Print error
  exit(-1);
}

// An error-checked malloc() wrapper function
void *ec_malloc(unsigned int size) {
  void *ptr;
  ptr = malloc(size);
  if (ptr == NULL)
    fatal("in ec_malloc() on memory allocation");
  return ptr;
}

/*

- File descriptors use a set of low-level I/O functions
- Filestreams are a higher-level form of buffered I/O that is built on the lower-level functions
- A file descriptor is a number that is used to reference open files
- Common functions that use file descriptors are open(), close(), read(), and write().
  All of these functions will return âˆ’1 if there is an error
- The open() function opens a file for reading and/or writing and returns a file descriptor.
  The returned file descriptor is just an integer value, but it is unique among open files
  and it's passed as an argument to the other functions like a pointer to the opened file.
- The arguments to the open() function are a pointer to the filename to open
  and a series of predefined flags that specify the access mode
- For the close() function, the file descriptor is the only argument
- The read() and write() functions' arguments are the file descriptor, a pointer to the data to read or write,
  and the number of bytes to read or write from that location.

fcntl.h
the access mode must use at least one of the following three flags:
O_RDONLY  Open file for read-only access
O_WRONLY  Open file for write-only access
O_RDWR    Open file for both read and write access
combined with botwise OR
O_APPEND  Write data at the end of the file
O_TRUNC   If the file already exists, truncate the file to 0 length
O_CREAT   Create the file if it doesn't exist

OUTPUT

./simplenote.out hello
[DEBUG] buffer @ 0x57416160: 'hello'
[DEBUG] datafile @ 0x574161d0: '/tmp/notes'
[DEBUG] file descriptor is 3
Note has been saved.

cat /tmp/notes

*/
