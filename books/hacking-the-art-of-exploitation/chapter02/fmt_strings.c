#include <stdio.h>

/*
gcc fmt_strings.c -o fmt_strings.out

These format parameters receive their data as values, not pointers to values
%d Decimal
%u Unsigned decimal (NO negative value)
%x Hexadecimal

The %s format parameter expects to be given a memory address;
it prints the data at that memory address until a null byte is encountered.
The %n format parameter is unique in that it actually writes data.
It also expects to be given a memory address,
and it writes the number of bytes that have been written so far into that memory address.
%s String
%n Number of bytes written so far
*/
int main() {
  char string[10];
  int A = -73;
  unsigned int B = 31337;

  strcpy(string, "sample");

  // Example of printing with different format string
  printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
  printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
  // Shows the usage of (minimum) field-width option in a format parameter
  // It adds blank spaces or if it begins with 0, it's padded with zeros
  printf("[field width on B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
  // the variable string is actually a pointer containing the address of the string
  // the %s format parameter expects its data to be passed by reference
  printf("[string] %s Address %08x\n", string, string);

  // Example of unary address operator (dereferencing) and a %x format string
  printf("variable A is at address: %08x\n", &A);
}

/*
When the variable A is printed using the %u format parameter, it appears as a very high value.
This is because A is a negative number stored in two's complement,
and the format parameter is trying to print it as if it were an unsigned value.
Since two's complement flips all the bits and adds one, the very high bits that used to be zero are now one.

OUTPUT

[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '     31337', '00031337'
[string] sample Address ffd70de2
variable A is at address: ffd70dd8
*/
