---
sidebar_position: 3
id: hacking-the-art-of-exploitation
title: "Hacking: The Art of Exploitation"
---

# Hacking: The Art of Exploitation

:::tip About
The goal of this book is to share the art of hacking with everyone

[Hacking: The Art of Exploitation (2008)(2nd)](https://nostarch.com/hacking2.htm)
:::

## Chapter 1: TODO

### Notes

Hacking is really just the act of finding a clever and counterintuitive solution to a problem

* *Machine language* consists of raw bits and bytes, and it differs from architecture to architecture
* An *assembler* is one form of machine-language translator: it is a program that translates *assembly language* into machine-readable code - the language is architecture specific
* A *compiler* converts a high-level language into machine language
* A program written in a high-level language is written once, and the same piece of program code can be compiled into machine language for various specific architectures
* The *GNU Compiler Collection* (GCC) is a free C compiler. The output is an executable binary file, which is called `a.out` by default
* C code is meant to be compiled. The code can't actually do anything until it's compiled into an executable binary file
* `objdump` included in the GNU development tools, can be used to examine compiled binaries
* Each byte is represented in *hexadecimal notation*, which is a base-16 numbering system. This is a convenient notation since a byte contains 8 bits, each of which can be either true or false. This means a byte has 256 (2^8) possible values, so each byte can be described with 2 hexadecimal digits
* The bits of the machine language instructions must be put somewhere, and this somewhere is called *memory*. Memory is just a
collection of bytes of temporary storage space that are numbered with addresses
* Memory can be thought of as a row of bytes, each with its own memory address. Each byte of memory can be accessed by its address, and in this case the CPU accesses this part of memory to retrieve the machine language instructions that make up the compiled program
* Older Intel x86 processors use a 32-bit addressing scheme, while newer ones use a 64-bit one. The 32-bit processors have 2^32 (or 4,294,967,296) possible addresses, while the 64-bit ones have 2^64 (1.84467441 × 10^19) possible addresses. The 64-bit processors can run in 32-bit compatibility mode
* Assembly language is really just a collection of mnemonics for the corresponding machine language instructions
* Unlike C and other compiled languages, assembly language instructions have a direct one-to-one relationship with their corresponding machine language instructions. This means that since every processor architecture has different machine language instructions, each also has a different form of assembly language. Assembly is just a way for programmers to represent the machine language instructions that are given to the processor: there are 2 main types, AT&T syntax and Intel syntax
* These instructions consist of an operation and sometimes additional arguments that describe the destination and/or the source for the operation. These operations move memory around, perform some sort of basic math, or interrupt the processor to get it to do something else. In the end, that’s all a computer processor can really do!
* Processors also have their own set of special variables called *registers*

```bash
# x86 (32 bits)
docker run --rm -it --name ubuntu -v "$(pwd)/books/hacking-the-art-of-exploitation:/share" i386/ubuntu:18.04 bash
apt-get update
apt-get install gcc gdb -y

cd share
gcc firstprog.c
./a.out

objdump -D a.out | grep -A20 main
objdump -D a.out -M intel | grep -A20 main
# <ADDRESS> <MACHINE_LANGUAGE_INSTRUCTION> <ASSEMBLY_LANGUAGE_INSTRUCTION>
```

> TODO 0x252

### Resources

> TODO

### Extra

> TODO

## Chapter 2

> TODO
