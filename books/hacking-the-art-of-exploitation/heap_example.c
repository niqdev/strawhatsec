#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// gcc -g heap_example.c -o heap_example.out
int main(int argc, char *argv[]) {
  char *char_ptr; // A char pointer
  int *int_ptr; // An integer pointer
  int mem_size;

  if (argc < 2) // If there aren't command-line arguments,
    mem_size = 50; // use 50 as the default value.
  else
    mem_size = atoi(argv[1]);

  printf("\t[+] allocating %d bytes of memory on the heap for char_ptr\n", mem_size);
  char_ptr = (char *) malloc(mem_size); // Allocating heap memory

  if (char_ptr == NULL) { // Error checking, in case malloc() fails
    fprintf(stderr, "Error: could not allocate heap memory.\n");
    exit(-1);
  }

  strcpy(char_ptr, "This is memory is located on the heap.");
  printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

  printf("\t[+] allocating 12 bytes of memory on the heap for int_ptr\n");
  int_ptr = (int *) malloc(12); // Allocated heap memory again

  if (int_ptr == NULL) { // Error checking, in case malloc() fails
    fprintf(stderr, "Error: could not allocate heap memory.\n");
    exit(-1);
  }

  *int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.
  printf("int_ptr (%p) --> %d\n", int_ptr, *int_ptr);

  printf("\t[-] freeing char_ptr's heap memory...\n");
  free(char_ptr); // Freeing heap memory

  printf("\t[+] allocating another 15 bytes for char_ptr\n");
  char_ptr = (char *) malloc(15); // Allocating more heap memory

  if (char_ptr == NULL) { // Error checking, in case malloc() fails
    fprintf(stderr, "Error: could not allocate heap memory.\n");
    exit(-1);
  }

  strcpy(char_ptr, "new memory");
  printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

  printf("\t[-] freeing int_ptr's heap memory...\n");
  free(int_ptr); // Freeing heap memory
  printf("\t[-] freeing char_ptr's heap memory...\n");
  free(char_ptr); // Freeing the other block of heap memory
}

/*

- Allocating memory on the heap is done using the malloc() function:
  it accepts a size as its only argument and reserves that much space in the heap segment,
  returning the address to the start of this memory as a void pointer.
  If the malloc() function can't allocate memory for some reason,
  it will simply return a NULL pointer with a value of 0
- Since malloc() doesn't know what type of memory it's allocating,
  it returns a void pointer to the newly allocated heap memory,
  which must be typecast into the appropriate type
- The corresponding deallocation function is free():
  this function accepts a pointer as its only argument and
  frees that memory space on the heap so it can be used again later
- The fprintf() function is very similar to printf(); however, its first argument is stderr,
  which is a standard filestream meant for displaying errors
- If a larger block of memory is allocated and then deallocated,
  the final 15-byte allocation will occur in that freed memory space, instead (0x56d46570)

OUTPUT

./heap_example.out 
	[+] allocating 50 bytes of memory on the heap for char_ptr
char_ptr (0x57462570) --> 'This is memory is located on the heap.'
	[+] allocating 12 bytes of memory on the heap for int_ptr
int_ptr (0x574625b0) --> 31337
	[-] freeing char_ptr's heap memory...
	[+] allocating another 15 bytes for char_ptr
char_ptr (0x574625c0) --> 'new memory'
	[-] freeing int_ptr's heap memory...
	[-] freeing char_ptr's heap memory...

./heap_example.out 10000
	[+] allocating 10000 bytes of memory on the heap for char_ptr
char_ptr (0x56d46570) --> 'This is memory is located on the heap.'
	[+] allocating 12 bytes of memory on the heap for int_ptr
int_ptr (0x56d48c90) --> 31337
	[-] freeing char_ptr's heap memory...
	[+] allocating another 15 bytes for char_ptr
char_ptr (0x56d46570) --> 'new memory'
	[-] freeing int_ptr's heap memory...
	[-] freeing char_ptr's heap memory...

*/
