; If the string is placed directly after a call instruction,
; the address of the string will get pushed to the stack as the return address.
; Instead of calling a function, we can jump past the string to a pop
; instruction that will take the address off the stack and into a register.
; Without using any memory segments, these raw instructions, injected into an existing process,
; will execute in a completely position-independent way. This means that,
; when these instructions are assembled, they cannot be linked into an executable.

BITS 32; Tell nasm this is 32-bit code.
  call mark_below; Call below the string to instructions
  msg db "Hello, world!", 0x0a, 0x0d; with newline and carriage return bytes.
  len equ $-msg; length of the string

mark_below:
  ; ssize_t write(int fd, const void *buf, size_t count);
  pop ecx; Pop the return address (string ptr) into ecx.
  mov eax, 4; Write syscall #.
  mov ebx, 1; STDOUT file descriptor
  mov edx, len; Length of the string
  int 0x80; Do syscall: write(1, string, 15)

  ; void _exit(int status);
  mov eax, 1; Exit syscall #
  mov ebx, 0; Status = 0
  int 0x80; Do syscall: exit(0)
