"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[314],{8422:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return o},metadata:function(){return m},toc:function(){return c}});var n=a(3117),i=a(102),r=(a(7294),a(3905)),s=["components"],o={sidebar_position:3,id:"hacking-the-art-of-exploitation",title:"Hacking: The Art of Exploitation"},l="Hacking: The Art of Exploitation",m={unversionedId:"notes/hacking-the-art-of-exploitation",id:"notes/hacking-the-art-of-exploitation",title:"Hacking: The Art of Exploitation",description:"The goal of this book is to share the art of hacking with everyone",source:"@site/../docs/notes/hacking-the-art-of-exploitation.md",sourceDirName:"notes",slug:"/notes/hacking-the-art-of-exploitation",permalink:"/strawhatsec/docs/notes/hacking-the-art-of-exploitation",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"hacking-the-art-of-exploitation",title:"Hacking: The Art of Exploitation"},sidebar:"tutorialSidebar",previous:{title:"The Shellcoder's Handbook",permalink:"/strawhatsec/docs/notes/the-shellcoder-s-handbook"},next:{title:"TODO",permalink:"/strawhatsec/docs/htb/todo"}},p={},c=[{value:"Chapter 0x200",id:"chapter-0x200",level:2},{value:"Notes",id:"notes",level:3},{value:"Resources",id:"resources",level:3},{value:"Extra",id:"extra",level:3},{value:"Chapter 0x300",id:"chapter-0x300",level:2},{value:"Notes",id:"notes-1",level:3},{value:"Extra",id:"extra-1",level:3},{value:"Chapter 0x400",id:"chapter-0x400",level:2},{value:"Notes",id:"notes-2",level:3},{value:"Resources",id:"resources-1",level:3},{value:"Extra",id:"extra-2",level:3},{value:"Chapter 0x500",id:"chapter-0x500",level:2},{value:"Extra",id:"extra-3",level:3}],h={toc:c};function d(e){var t=e.components,o=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"hacking-the-art-of-exploitation"},"Hacking: The Art of Exploitation"),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"About")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The goal of this book is to share the art of hacking with everyone"),(0,r.kt)("p",{parentName:"div"},(0,r.kt)("a",{parentName:"p",href:"https://nostarch.com/hacking2.htm"},"Hacking: The Art of Exploitation (2008)(2nd)")))),(0,r.kt)("h2",{id:"chapter-0x200"},"Chapter 0x200"),(0,r.kt)("h3",{id:"notes"},"Notes"),(0,r.kt)("p",null,"Hacking is really just the act of finding a clever and counterintuitive solution to a problem"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Machine language")," consists of raw bits and bytes, and it differs from architecture to architecture"),(0,r.kt)("li",{parentName:"ul"},"An ",(0,r.kt)("em",{parentName:"li"},"assembler")," is one form of machine-language translator: it is a program that translates architecture specific ",(0,r.kt)("em",{parentName:"li"},"assembly language")," into machine-readable code"),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("em",{parentName:"li"},"compiler")," converts a high-level language into machine language"),(0,r.kt)("li",{parentName:"ul"},"A program written in a high-level language is written once, and the same piece of program code can be compiled into machine language for various specific architectures"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"GNU Compiler Collection")," (GCC) is a free C compiler which outputs executable binary files"),(0,r.kt)("li",{parentName:"ul"},"C code is meant to be compiled. The code can't actually do anything until it's compiled into an executable binary file"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"objdump"),", included in the GNU development tools, can be used to examine compiled binaries"),(0,r.kt)("li",{parentName:"ul"},"Each byte is represented in ",(0,r.kt)("em",{parentName:"li"},"hexadecimal notation"),", which is a base-16 numbering system. This is a convenient notation since a byte contains 8 bits, each of which can be either true or false. This means a byte has 256 (2^8) possible values, so each byte can be described with 2 hexadecimal digits"),(0,r.kt)("li",{parentName:"ul"},"The bits of the machine language instructions must be put somewhere, and this somewhere is called ",(0,r.kt)("em",{parentName:"li"},"memory"),". Memory is just a\ncollection of bytes of temporary storage space that are numbered with addresses"),(0,r.kt)("li",{parentName:"ul"},"Memory can be thought of as a row of bytes, each with its own memory address. Each byte of memory can be accessed by its address, and in this case the CPU accesses this part of memory to retrieve the machine language instructions that make up the compiled program"),(0,r.kt)("li",{parentName:"ul"},"Older Intel x86 processors use a 32-bit addressing scheme, while newer ones use a 64-bit one. The 32-bit processors have 2^32 (or 4,294,967,296) possible addresses, while the 64-bit ones have 2^64 (1.84467441 \xd7 10^19) possible addresses. The 64-bit processors can run in 32-bit compatibility mode"),(0,r.kt)("li",{parentName:"ul"},"Assembly language is really just a collection of mnemonics for the corresponding machine language instructions"),(0,r.kt)("li",{parentName:"ul"},"Unlike C and other compiled languages, assembly language instructions have a direct one-to-one relationship with their corresponding machine language instructions. This means that since every processor architecture has different machine language instructions, each processor also has a different form of assembly language. Assembly is just a way for programmers to represent the machine language instructions that are given to the processor: there are 2 main types, AT&T syntax and Intel syntax"),(0,r.kt)("li",{parentName:"ul"},"These instructions consist of an operation and sometimes additional arguments that describe the destination and/or the source for the operation. These operations move memory around, perform some sort of basic math, or interrupt the processor to get it to do something else. In the end, that\u2019s all a computer processor can really do!"),(0,r.kt)("li",{parentName:"ul"},"Processors also have their own set of special variables called ",(0,r.kt)("em",{parentName:"li"},"registers")),(0,r.kt)("li",{parentName:"ul"},"The 8086 CPU was the first x86 processor, amd it was developed and manufactured by Intel"),(0,r.kt)("li",{parentName:"ul"},"The GNU development tools also include a ",(0,r.kt)("em",{parentName:"li"},"debugger")," called GDB. Debuggers are used by programmers to step through compiled programs, examine program memory, and view processor registers."),(0,r.kt)("li",{parentName:"ul"},"GDB is used to show the state of the processor registers right before the program starts"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"General-purpose")," registers:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Accumulator ",(0,r.kt)("inlineCode",{parentName:"li"},"EAX")),(0,r.kt)("li",{parentName:"ul"},"Counter ",(0,r.kt)("inlineCode",{parentName:"li"},"ECX")),(0,r.kt)("li",{parentName:"ul"},"Data ",(0,r.kt)("inlineCode",{parentName:"li"},"EDX")),(0,r.kt)("li",{parentName:"ul"},"Base ",(0,r.kt)("inlineCode",{parentName:"li"},"EBX")),(0,r.kt)("li",{parentName:"ul"},"They are used for a variety of purposes, but they mainly act as temporary variables for the CPU when it is executing machine instructions"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Pointers")," registers:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Stack Pointer ",(0,r.kt)("inlineCode",{parentName:"li"},"ESP")),(0,r.kt)("li",{parentName:"ul"},"Base Pointer ",(0,r.kt)("inlineCode",{parentName:"li"},"EBP")),(0,r.kt)("li",{parentName:"ul"},"They are called pointers because they store 32-bit addresses, which essentially point to that location in memory"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Indexes")," registers:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Source Index ",(0,r.kt)("inlineCode",{parentName:"li"},"ESI")),(0,r.kt)("li",{parentName:"ul"},"Destination Index ",(0,r.kt)("inlineCode",{parentName:"li"},"EDI")),(0,r.kt)("li",{parentName:"ul"},"They are also technically pointers, which are commonly used to point to the source and destination when data needs to be read from or written to"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Instruction Pointer")," register ",(0,r.kt)("inlineCode",{parentName:"li"},"EIP")," points to the current instruction the processor is reading during a programs execution by containing its memory address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Extended Flags")," register ",(0,r.kt)("inlineCode",{parentName:"li"},"EFLAGS")," consists of several bit flags that are used for comparisons and memory segmentations. The actual memory is split into several different segments, and these registers keep track of that"),(0,r.kt)("li",{parentName:"ul"},"Assembly instructions in Intel syntax",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"generally follow this style: ",(0,r.kt)("inlineCode",{parentName:"li"},"operation <destination>, <source>")),(0,r.kt)("li",{parentName:"ul"},"destination and source values will either be a register, a memory address, or a value"))),(0,r.kt)("li",{parentName:"ul"},"The instructions before the ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," entrypoint are collectively known as the ",(0,r.kt)("em",{parentName:"li"},"function prologue")," and are generated by the compiler to set up memory for the rest of the main() function's local variables. Part of the reason variables need to be declared in C is to aid the construction of this section of code. The debugger knows this part of the code is automatically generated and is smart enough to skip over it"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," examine command in GDB can be used to look at a certain address of memory",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This command expects two arguments when it's used: the location in memory to examine and how to display that memory"),(0,r.kt)("li",{parentName:"ul"},"The display format also uses a single-letter shorthand, which is optionally preceded by a count of how many items to examine",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"o")," Display in octal"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x")," Display in hexadecimal"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"u")," Display in unsigned, standard base-10 decimal"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"t")," Display in binary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"c")," Look up a byte on the ASCII table"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"s")," Display in string"))),(0,r.kt)("li",{parentName:"ul"},"The default size of a single unit is a four-byte unit called a ",(0,r.kt)("em",{parentName:"li"},"word"),". The size of the display units for the examine command can be changed by adding a size letter to the end of the format letter",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"b")," A single byte"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"h")," A halfword, which is two bytes in size"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"w")," A word, which is four bytes in size. In this case a double word or ",(0,r.kt)("em",{parentName:"li"},"DWORD")," refers to a 4-byte value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"g")," A giant, which is eight bytes in size"))),(0,r.kt)("li",{parentName:"ul"},"The examine command also accepts the format letter ",(0,r.kt)("inlineCode",{parentName:"li"},"i"),", short for instruction, to display the memory as disassembled assembly language instructions"))),(0,r.kt)("li",{parentName:"ul"},"x86 processor values are stored in ",(0,r.kt)("em",{parentName:"li"},"little-endian byte order"),", which means the least significant byte is stored first. For example, if four bytes are to be interpreted as a single value, the bytes must be used in reverse order"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"bt")," command can be used to ",(0,r.kt)("em",{parentName:"li"},"backtrace")," the stack"),(0,r.kt)("li",{parentName:"ul"},"All numerical values are stored in binary",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a 32-bit unsigned integer can contain values from 0 (all binary 0s) to (2^32 -1) 4,294,967,295 (all binary 1s)"),(0,r.kt)("li",{parentName:"ul"},"a 32-bit signed integer range from (-2^31) \u22122,147,483,648 to (2^31 -1) 2,147,483,647. Essentially, one of the bits is a flag marking the value positive or negative"),(0,r.kt)("li",{parentName:"ul"},"positively signed values look the same as unsigned values, but negative numbers are stored differently using a method called ",(0,r.kt)("em",{parentName:"li"},"two's complement")),(0,r.kt)("li",{parentName:"ul"},"the backtrace shows the nested function calls by looking at records kept on the stack. Each time a function is called, a record called a ",(0,r.kt)("em",{parentName:"li"},"stack frame")," is put on the stack. Each line in the backtrace corresponds to a stack frame. Each stack frame also contains the local variables for that context"))),(0,r.kt)("li",{parentName:"ul"},"To see the actual data stored in a pointer variable, you can use the unary operator ",(0,r.kt)("inlineCode",{parentName:"li"},"&")," ampersand called ",(0,r.kt)("em",{parentName:"li"},"address-of")," operator"),(0,r.kt)("li",{parentName:"ul"},"To see the data found in the address the pointer is pointing to, instead of the address itself, you can use the unary operator ",(0,r.kt)("inlineCode",{parentName:"li"},"*")," asterisk called ",(0,r.kt)("em",{parentName:"li"},"dereference")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Typecasting")," is simply a way to temporarily change a variable's data type, despite how it was originally defined"),(0,r.kt)("li",{parentName:"ul"},"Memory is split into ",(0,r.kt)("em",{parentName:"li"},"segments"),", and some memory addresses aren't within the boundaries of the memory segments the program is given access to. When the program attempts to access an address that is out of bounds, it will crash and die in what's called a ",(0,r.kt)("em",{parentName:"li"},"segmentation fault")),(0,r.kt)("li",{parentName:"ul"},"A compiled program's memory is divided into five segments: text, data, bss, heap, and stack"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"text segment")," is also sometimes called the ",(0,r.kt)("em",{parentName:"li"},"code segment")," and it's where the assembled machine language instructions of the program are located",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"as a program executes, the EIP is set to the first instruction in the text segment, the processor then follows an execution loop that does the following:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"reads the instruction that EIP is pointing to"),(0,r.kt)("li",{parentName:"ol"},"adds the byte length of the instruction to EIP"),(0,r.kt)("li",{parentName:"ol"},"executes the instruction that was read in step 1"),(0,r.kt)("li",{parentName:"ol"},"goes back to step 1"))),(0,r.kt)("li",{parentName:"ul"},"sometimes the instruction will be a jump or a call instruction, which changes the EIP to a different address of memory. The processor doesn't care about the change, because it's expecting the execution to be nonlinear anyway"),(0,r.kt)("li",{parentName:"ul"},"write permission is disabled in the text segment, as it is not used to store variables, only code. It can be shared among different copies of the program, allowing multiple executions of the program at the same time without any problems. This memory segment has a fixed size, since nothing ever changes in it"))),(0,r.kt)("li",{parentName:"ul"},"The data and bss segments are used to store global and static program variables",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("em",{parentName:"li"},"data segment")," is filled with the initialized global and static variables"),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("em",{parentName:"li"},"bss segment")," is filled with their uninitialized counterparts"),(0,r.kt)("li",{parentName:"ul"},"although these segments are writable, they have a fixed size"))),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"heap segment")," is a segment of memory a programmer can directly control and use for whatever might need, memory can be reserved and free on the fly",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the heap segment isn't of fixed size, so it can grow larger or smaller as needed"),(0,r.kt)("li",{parentName:"ul"},"the growth of the heap moves downward toward higher memory addresses"),(0,r.kt)("li",{parentName:"ul"},"the heap will grow and shrink depending on how much memory is reserved for use"),(0,r.kt)("li",{parentName:"ul"},"all of the memory within the heap is managed by allocator and deallocator algorithms, which respectively reserve a region of memory in the heap for use and remove reservations to allow that portion of memory to be reused for later reservations"))),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"stack segment")," also has variable size and is used as a temporary scratch pad to store local function variables and context during function calls",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"this is what GDB's backtrace ",(0,r.kt)("inlineCode",{parentName:"li"},"bt")," command looks at"),(0,r.kt)("li",{parentName:"ul"},"when a program calls a function, that function will have its own set of passed variables, and the function's code will be at a different memory location in the text (or code) segment. Since the context and the EIP must change when a function is called, the stack is used to remember all of the passed variables, the location the EIP should return to after the function is finished, and all the local variables used by that function. All of this information is stored together on the stack in what is collectively called a ",(0,r.kt)("em",{parentName:"li"},"stack frame"),". The stack contains many stack frames"),(0,r.kt)("li",{parentName:"ul"},"a stack is an abstract data structure, it has first-in, last-out (FILO) ordering, which means the first item that is put into a stack is the last item to come out of it"),(0,r.kt)("li",{parentName:"ul"},"when an item is placed into a stack, it's known as ",(0,r.kt)("em",{parentName:"li"},"pushing"),", and when an item is removed from a stack, it's called ",(0,r.kt)("em",{parentName:"li"},"popping")),(0,r.kt)("li",{parentName:"ul"},"the stack segment of memory is, in fact, a stack data structure, which contains stack frames"),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"ESP")," register is used to keep track of the address of the end of the stack, which is constantly changing as items are pushed into and popped off of it"),(0,r.kt)("li",{parentName:"ul"},"the stack is also not of a fixed size. Opposite to the dynamic growth of the heap, as the stack changes in size, it grows upward in a visual listing of memory, toward lower memory addresses"),(0,r.kt)("li",{parentName:"ul"},"the FILO nature of a stack might seem odd, but since the stack is used to store context, it's very useful"),(0,r.kt)("li",{parentName:"ul"},"when a function is called, several things are pushed to the stack together in a stack frame",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"EBP")," register, sometimes called the ",(0,r.kt)("em",{parentName:"li"},"frame pointer")," (FP) or ",(0,r.kt)("em",{parentName:"li"},"local base")," (LB) pointer, is used to reference local function variables in the current stack frame"),(0,r.kt)("li",{parentName:"ul"},"each stack frame contains the parameters to the function, its local variables, and two pointers that are necessary to put things back the way they were: the ",(0,r.kt)("em",{parentName:"li"},"saved frame pointer")," (SFP) and the ",(0,r.kt)("em",{parentName:"li"},"return address")),(0,r.kt)("li",{parentName:"ul"},"the SFP is used to restore EBP to its previous value, and the return address is used to restore EIP to the next instruction found after the function call. This restores the functional context of the previous stack frame"))))),(0,r.kt)("li",{parentName:"ul"},"The first few instructions of each function set up the stack frame. These instructions are collectively called the ",(0,r.kt)("em",{parentName:"li"},"procedure prologue")," or ",(0,r.kt)("em",{parentName:"li"},"function prologue"),". They save the frame pointer on the stack, and they save stack memory for the local function variables. Sometimes the function prologue will handle some stack alignment as well. The exact prologue instructions will vary greatly depending on the compiler and compiler options, but in general these instructions build the stack frame")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'# x86 (32 bits) + remove ASLR warning\ndocker run --rm -it \\\n  --name ubuntu \\\n  --cap-add=SYS_PTRACE \\\n  --security-opt seccomp=unconfined \\\n  -v "$(pwd)/notes/hacking-the-art-of-exploitation:/share" \\\n  --platform linux/386 \\\n  i386/ubuntu:18.04 \\\n  bash\n# install C compiler and debugger\napt-get update && apt-get install gcc gdb -y\n\ncd /share/chapter02\ngcc firstprog.c\n# default binary file name\n./a.out\n\nobjdump -D a.out | grep -A20 main\nobjdump -D a.out -M intel | grep -A20 main\n# <ADDRESS> <MACHINE_LANGUAGE_INSTRUCTION> <ASSEMBLY_LANGUAGE_INSTRUCTION>\n')),(0,r.kt)("p",null,"Little-endian explained"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"gdb -q ./a.out \n(gdb) break main\n(gdb) run\n#...\n(gdb) x/4xb $eip\n0x5655e53a <main+29>:   0xc7    0x45    0xf4    0x00\n(gdb) x/4ub $eip\n0x5655e53a <main+29>:   199     69      244     0\n(gdb) x/1xw $eip\n0x5655e53a <main+29>:   0x00f445c7\n(gdb) x/1uw $eip\n0x5655e53a <main+29>:   16008647\n\nbc -ql\n199*(256^3)+69*(256^2)+244*(256^1)+0*(256^0)\n3343250432\n0*(256^3)+244*(256^2)+69*(256^1)+199*(256^0)\n16008647\n\n# the seven bytes EIP is pointing to actually are machine language\n# for the corresponding assembly instruction\nobjdump -D a.out -M intel | grep -A20 main\n#...\n 53a:   c7 45 f4 00 00 00 00    mov    DWORD PTR [ebp-0xc],0x0\n")),(0,r.kt)("p",null,"Remove modern protections"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'# includes symbols: -g\n# to build 32-bit code on a 64-bit machine: -m32\n# disable canary: -fno-stack-protector\n# disable DEP: -z execstack\n# to have the compiler generate asm that doesn\'t bother with PIE stuff: -fno-pie\n# disable PIE to have it not link that machine code into a PIE: -no-pie\ngcc -g -m32 -fno-stack-protector -z execstack -fno-pie -no-pie firstprog.c -o firstprog.out\n\n# disable ASLR in host (outside docker)\nsysctl -n kernel.randomize_va_space\nsysctl -w kernel.randomize_va_space=0\n\n# debugger\ngdb -q ./firstprog.out\n#(gdb) set disassembly intel\n#(gdb) list\n#(gdb) disassemble main\n#(gdb) break main\n#(gdb) run\n#(gdb) info registers\n#(gdb) info registers eip\n#(gdb) i r eip\n#(gdb) x/o 0x565dc53a\n#(gdb) x/x $eip   \n#(gdb) x/u $eip\n#(gdb) x/t $eip\n#(gdb) x/10x $eip\n#(gdb) x/8xb $eip\n#(gdb) x/8xh $eip\n#(gdb) x/8xw $eip\n#(gdb) x/i $eip\n#(gdb) x/3i $eip\n#(gdb) print $ebp - 4\n#(gdb) x/6cb <ADDRESS>\n#(gdb) x/s <ADDRESS>\n#(gdb) print &pointer\n#(gdb) print *pointer\n#(gdb) nexti\n#(gdb) where\n#(gdb) quit\n\n# use it as hexadecimal calculator\ngdb -q --batch -ex "p 0xbb - 0xaa"\n\n# default config\necho "set disassembly intel" > ~/.gdbinit\n\n# ASCII table\nman ascii\n')),(0,r.kt)("p",null,"Analysis"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                       \u2502 440            \u25c4\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502 448 PUTS       \u2502  \u2502\n\u2502 437 SET 0      \u2502     \u2502 450 INC 1      \u2502  \u2502\n\u2502 43e JMP to 454 \u251c\u2500\u2500\u2500\u2500\u2500\u25ba 454 CMP == 9   \u2502  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502 458 JLE 440    \u251c\u2500\u2500\u2518\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                            \u250c\u2500\u2500\u25bc\u2500\u2500\u2510\n                            \u2502 45a \u2502\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nDump of assembler code for function main:\n   0x08048426 <+0>:     lea    ecx,[esp+0x4]\n   0x0804842a <+4>:     and    esp,0xfffffff0\n   0x0804842d <+7>:     push   DWORD PTR [ecx-0x4]\n   0x08048430 <+10>:    push   ebp\n   0x08048431 <+11>:    mov    ebp,esp\n   0x08048433 <+13>:    push   ecx\n   0x08048434 <+14>:    sub    esp,0x14\n\n   # MAIN\n   0x08048437 <+17>:    mov    DWORD PTR [ebp-0xc],0x0      ; 437 SET 0\n   0x0804843e <+24>:    jmp    0x8048454 <main+46>          ; 43e JMP to 454 (#1)\n\n   # LOOP\n   0x08048440 <+26>:    sub    esp,0xc                      ; 440 (#2)\n   0x08048443 <+29>:    push   0x80484f0\n   0x08048448 <+34>:    call   0x80482e0 <puts@plt>         ; 448 PUTS\n   0x0804844d <+39>:    add    esp,0x10\n   0x08048450 <+42>:    add    DWORD PTR [ebp-0xc],0x1      ; 450 INC 1\n   0x08048454 <+46>:    cmp    DWORD PTR [ebp-0xc],0x9      ; 454 CMP == 9 (#1)\n   0x08048458 <+50>:    jle    0x8048440 <main+26>          ; 458 JLE to 440 (#2)\n\n   # EXIT\n   0x0804845a <+52>:    mov    eax,0x0\n   0x0804845f <+57>:    mov    ecx,DWORD PTR [ebp-0x4]\n   0x08048462 <+60>:    leave  \n   0x08048463 <+61>:    lea    esp,[ecx-0x4]\n   0x08048466 <+64>:    ret    \nEnd of assembler dump.\n")),(0,r.kt)("p",null,"Other examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# char_array\n# datatype_sizes\n# pointer\n# addressof\n# fmt_strings\n# input\n# typecasting\n# pointer_types\n# commandline\n# convert\n# scope\n# static\n# stack_example\n# memory_segments\n# heap_example\n# errorchecked_heap\n# simplenote\n# bitwise\n# fcntl_flags\n# uid_demo\n# notetaker\n# notesearch\n# time_example\n# funcptr_example\n# rand_example\n# game_of_chance (from sources)\ngcc -g -m32 -fno-stack-protector -z execstack -fno-pie -no-pie <PROGRAM>.c -o <PROGRAM>.out\n\ngdb -q ./<PROGRAM>.out\n")),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",alt:"memory-segmentation!",src:a(6441).Z,title:"memory-segmentation",width:"513",height:"506"})),(0,r.kt)("h3",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/vapier/pcalc"},"pcalc"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/vapier/pcalc.git\ncd pcalc/\napt install make bison flex\nmake\nmake install\npcalc\n")),(0,r.kt)("h3",{id:"extra"},"Extra"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://tyeyeah.github.io/2020/01/23/2020-01-23-Security-Protection-Mechanism"},"Security Protection Mechanism")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage"},"Stack Canaries")," to prevent ",(0,r.kt)("inlineCode",{parentName:"li"},"stack smashing detected")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/a/40867982"},"How to turn off gcc compiler optimization to enable buffer overflow")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld"},"What is the -fPIE option for position-independent executables in gcc?")," about ",(0,r.kt)("inlineCode",{parentName:"li"},"PIE")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ASLR")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/35860527/warning-error-disabling-address-space-randomization-operation-not-permitted"},"Error disabling address space randomization: Operation not permitted")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://visualgdb.com/gdbreference/commands/set_disable-randomization"},"set disable-randomization command")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html"},"Two's Complement"))),(0,r.kt)("h2",{id:"chapter-0x300"},"Chapter 0x300"),(0,r.kt)("h3",{id:"notes-1"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Exploiting a program is simply a clever way of getting the computer to do what you want it to do, even if the currently running program was designed to prevent that action. A program can only do what it's programmed to do, to the letter of the law. Unfortunately, what's written doesn't always coincide with what the programmer intended the program to do."),(0,r.kt)("li",{parentName:"ul"},"Off-by-one errors and improper Unicode expansion are all mistakes that can be hard to see at the time but are glaringly obvious to any programmer in\nhindsight"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Buffer Overrun")," or ",(0,r.kt)("em",{parentName:"li"},"Buffer Overflow"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd /share/chapter03\n\n# overflow_example\n# exploit_notesearch\n# auth_overflow\n# getenv_example\n# getenvaddr\n# fmt_uncommon\n# fmt_vuln\n# dtors_sample\n\n# exploit_notetaker.txt\n# exploit_game_of_chance.txt\n# exploit_global_offset_table.txt\n")),(0,r.kt)("p",null,"Generate payloads"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'# perl\nperl -e \'print "A" x 27;\'\nperl -e \'print "\\x41" x 20;\'\nperl -e \'print "A"x20 . "BCD" . "\\x61\\x66\\x67\\x69"x2 . "Z";\'\n# little endian: de|ad|be|ef\nperl -e \'print "A"x16 . "\\xef\\xbe\\xad\\xde"\'\n$(perl -e \'print "uname";\')\nuna$(perl -e \'print "m";\')e\nu`perl -e \'print "na";\'`me\nu$(perl -e \'print "na";\')me\nperl -e \'print crypt("password", "salt"). "\\n"\'\n\n# python\npython -c \'print "A"*27\'\npython -c \'import sys; sys.stdout.write("A"*27 + "\\x90"*4)\'\n\nfor i in {1..5}; do echo "hello"; done\nfor i in $(seq 0 30 300); do echo "hello-$i"; done\n')),(0,r.kt)("p",null,"Others"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# list symbols\nnm <BINARY>\n")),(0,r.kt)("h3",{id:"extra-1"},"Extra"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.gdbgui.com"},"gdbgui"))),(0,r.kt)("h2",{id:"chapter-0x400"},"Chapter 0x400"),(0,r.kt)("h3",{id:"notes-2"},"Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The seven OSI layers are as follows:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Physical layer")," deals with the physical connection between two points. This is the lowest layer, whose primary role is communicating raw bit streams. This layer is also responsible for activating, maintaining, and deactivating these bit-stream communications ",(0,r.kt)("em",{parentName:"li"},"e.g. Ethernet Cable and Card")),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Data-link layer")," deals with actually transferring data between two points. In contrast with the physical layer, which takes care of sending the raw bits, this layer provides high-level functions, such as error correction and flow control. This layer also provides procedures for activating, maintaining, and deactivating data-link connections ",(0,r.kt)("em",{parentName:"li"},"e.g. Ethernet"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Every Ethernet device is assigned a globally unique address consisting of six bytes, usually written in hexadecimal in the form ",(0,r.kt)("inlineCode",{parentName:"li"},"xx:xx:xx:xx:xx:xx"),", known as Media Access Control (MAC) addresses"),(0,r.kt)("li",{parentName:"ul"},"An Ethernet header is 14 bytes in size and contains the source and destination MAC addresses for this Ethernet packet"),(0,r.kt)("li",{parentName:"ul"},"Ethernet addressing also provides a special broadcast address, consisting of all binary 1's ",(0,r.kt)("inlineCode",{parentName:"li"},"ff:ff:ff:ff:ff:ff")),(0,r.kt)("li",{parentName:"ul"},"The MAC address of a network device isn't meant to change, but its IP address may change regularly. The concept of IP addresses doesn't exist at this level, only hardware addresses do. To correlate the two addressing schemes, the Address Resolution Protocol (ARP) is used. There are four different types of ARP messages, but the two most important types are ",(0,r.kt)("em",{parentName:"li"},"ARP request messages")," and ",(0,r.kt)("em",{parentName:"li"},"ARP reply messages")))),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Network layer")," works as a middle ground; its primary role is to pass information between the lower and the higher layers. It provides addressing and routing ",(0,r.kt)("em",{parentName:"li"},"e.g. IP address and router")),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Transport layer")," provides transparent transfer of data between systems. By providing reliable data communication, this layer allows the higher layers to never worry about reliability or cost-effectiveness of data transmission e.g. ",(0,r.kt)("em",{parentName:"li"},"TCP")),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Session layer")," is responsible for establishing and maintaining connections between network applications"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Presentation layer")," is responsible for presenting the data to applications in a syntax or language they understand. This allows for things like encryption and data compression"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Application layer")," is concerned with keeping track of the requirements of the application ",(0,r.kt)("em",{parentName:"li"},"e.g. HTTP, SMTP, IMAP, FTP")))),(0,r.kt)("li",{parentName:"ul"},"When data is communicated through these protocol layers, it's sent in small pieces called packets. Each packet contains implementations of these protocol layers and wraps the previous layer. This process is called encapsulation. Each wrapped layer contains a header and a body. The header contains the protocol information needed for that layer, while the body contains the data for that layer. The body of one layer contains the entire package of previously\nencapsulated layers."),(0,r.kt)("li",{parentName:"ul"},"A socket is a standard way to perform network communication through the OS. A socket can be thought of as an endpoint to a connection, but they are just a programmer's abstraction that takes care of all the nitty-gritty details of the OSI model. To the programmer, a socket can be used to send or receive data over a network at the session layer. The most common types are stream sockets (Transmission Control Protocol) and datagram sockets (User Datagram Protocol)"),(0,r.kt)("li",{parentName:"ul"},"In C, sockets behave a lot like files since they use file descriptors to identify themselves. The port number and IP address used in the AF_INET socket address structure are expected to follow the network byte ordering, which is big-endian. This is the opposite of x86's little-endian byte ordering")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd /share/chapter04\n\n# simple_server\n# host_lookup\n# webserver_id\n# tinyweb\n# raw_tcpsniff\n# pcap_sniff\n# decode_sniff\n# synflood\n# rst_hijack\n")),(0,r.kt)("p",null,"Sources"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"/usr/include/i386-linux-gnu/sys/socket.h\n/usr/include/i386-linux-gnu/bits/socket.h\n/usr/include/i386-linux-gnu/bits/socket_type.h\n/usr/include/netinet/in.h\n/usr/include/arpa/inet.h\n/usr/include/netdb.h\n/usr/include/linux/if_ether.h\n/usr/include/netinet/ip.h\n/usr/include/netinet/tcp.h\n")),(0,r.kt)("p",null,"Network Sniffing"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"On an ",(0,r.kt)("em",{parentName:"li"},"unswitched network"),", Ethernet packets pass through every device on the network, expecting each system device to only look at the packets sent to its destination address"),(0,r.kt)("li",{parentName:"ul"},"If a device is set to ",(0,r.kt)("em",{parentName:"li"},"promiscuous mode"),", it looks at all packets, regardless of the destination address"),(0,r.kt)("li",{parentName:"ul"},"In a ",(0,r.kt)("em",{parentName:"li"},"switched network")," environment, packets are only sent to the port they are destined for, according to their destination MAC addresses, so promiscuous devices aren't able to sniff any additional packets"),(0,r.kt)("li",{parentName:"ul"},"The act of forging a source address in a packet is known as ",(0,r.kt)("em",{parentName:"li"},"spoofing")),(0,r.kt)("li",{parentName:"ul"},"ARP cache poisoning",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"when an ARP reply comes in with an IP address that already exists in the ARP cache, the receiving system will overwrite the prior MAC address information with the new information found in the reply"),(0,r.kt)("li",{parentName:"ul"},"no state information about the ARP traffic is kept: systems will accept an ARP reply even if they didn't send out an ARP request"),(0,r.kt)("li",{parentName:"ul"},"the attacker sends spoofed ARP replies to certain devices that cause the ARP cache entries to be overwritten with the attacker's data"),(0,r.kt)("li",{parentName:"ul"},"due to timeout values, the victim machines will periodically send out real ARP requests and receive real ARP replies in response. In order to maintain the redirection attack, the attacker must keep the victim machine's ARP caches poisoned"))),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("em",{parentName:"li"},"gateway")," is a system that routes all the traffic from a local network out to the Internet")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# enable promiscuous mode\nsudo ifconfig eth0 promisc\n\nsudo tcpdump -l -X 'ip host <IP_ADDRESS>'\n")),(0,r.kt)("p",null,"Denial of Service (most of the attacks are obsolete)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A DoS attack simply prevents access to a service or resource. There are two general forms of attacks: those that crash services and those that flood services"),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("em",{parentName:"li"},"SYN flood")," tries to exhaust states in the TCP/IP stack: the kernel has a finite table that can only track so many incoming connections",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a technique called syncookies to try to prevent SYN flood attack: the TCP connections don't actually become active until the final ACK packet for the TCP handshake is checked"))),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"Ping of Death"),": ICMP echo messages can only have 2^16, or 65.536, bytes of data in the data part of the packet. Several operating systems crashed if they were sent ICMP echo messages that exceeded the size specified. See also ",(0,r.kt)("em",{parentName:"li"},"Bluesmack")," for Bluetooth"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Teardrop")," exploited IP fragmentation reassembly"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Ping/UDP Flooding")," also ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"an attacker with greater bandwidth than a victim can send more data than the victim can receive and therefore deny other legitimate traffic from getting to the victim"),(0,r.kt)("li",{parentName:"ul"},"an ",(0,r.kt)("em",{parentName:"li"},"amplification attack")," uses spoofing and broadcast addressing to amplify a single stream of packets by a hundred-fold: also known as ",(0,r.kt)("em",{parentName:"li"},"smurf")," and ",(0,r.kt)("em",{parentName:"li"},"fraggle")," attacks"))),(0,r.kt)("li",{parentName:"ul"},"In a DDoS attack, the attacker first compromises a number of other hosts and installs daemons on them. Systems installed with such software are commonly referred to as bots and make up what is known as a botnet")),(0,r.kt)("p",null,"TCP/IP hijacking"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"TCP/IP hijacking is a clever technique that uses spoofed packets to take over a connection between a victim and a host machine"),(0,r.kt)("li",{parentName:"ul"},"RST Hijacking involves injecting an authentic-looking reset (RST) packet. If the source is spoofed and the acknowledgment number is correct, the receiving side will believe that the source actually sent the reset packet, and the connection will be reset",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"libpcap provides a way to tell the kernel to only send certain packets that match a filter. This filter, known as a Berkeley Packet Filter (BPF), is very similar to a program")))),(0,r.kt)("p",null,"Port Scanning"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Port scanning is a way of figuring out which ports are listening and accepting connections",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the simplest form of port scanning involves trying to open TCP connections to every possible port on the target system: it's noisy and detectable"))),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("em",{parentName:"li"},"SYN scan")," ",(0,r.kt)("inlineCode",{parentName:"li"},"nmap -sS")," is also sometimes called a half-open scan",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The TCP/IP handshake: when a full connection is made, first a SYN packet is sent, then a SYN/ACK packet is sent back, and finally an ACK packet is returned to complete the handshake and open the connection"),(0,r.kt)("li",{parentName:"ul"},"A SYN scan doesn't complete the handshake, so a full connection is never opened"),(0,r.kt)("li",{parentName:"ul"},"If a SYN/ACK packet is received in response, that port must be accepting connections. This is recorded, and an RST packet is sent to tear down the connection"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"FIN")," ",(0,r.kt)("inlineCode",{parentName:"li"},"nmap -sF"),", ",(0,r.kt)("em",{parentName:"li"},"X-mas")," ",(0,r.kt)("inlineCode",{parentName:"li"},"nmap -sX"),", and ",(0,r.kt)("em",{parentName:"li"},"Null scans")," ",(0,r.kt)("inlineCode",{parentName:"li"},"nmap -sN")," techniques involve sending a nonsensical packet to every port on the target system: if a port is listening, these packets just get ignored. However, if the port is closed and the implementation follows protocol (RFC 793), an RST packet will be sent. This difference can be used to detect which ports are accepting connections, without actually opening any connections",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"FIN scan sends a FIN packet"),(0,r.kt)("li",{parentName:"ul"},"X-mas scan sends a packet with FIN, URG, and PUSH turned on"),(0,r.kt)("li",{parentName:"ul"},"Null scan sends a packet with no TCP flags set"),(0,r.kt)("li",{parentName:"ul"},"they are stealthier, but they can also be unreliable: Microsoft's implementation of TCP doesn't send RST packets"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Spoofing Decoys")," ",(0,r.kt)("inlineCode",{parentName:"li"},"nmap -D")," to avoid detection. This technique simply spoofs connections from various decoy real IP addresses of live hosts in between each real port-scanning connection"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Idle scanning")," ",(0,r.kt)("inlineCode",{parentName:"li"},"nmap -sI")," is a way to scan a target using spoofed packets from an idle host, by observing changes in the idle host that is not sending or receiving any other network traffic and that has a TCP implementation that produces predictable IP IDs that change by a known increment with each packet. IP IDs are meant to be unique per packet per session")),(0,r.kt)("h3",{id:"resources-1"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc826"},"RFC 826"),": Address Resolution Protocol"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc791"},"RFC 791"),": Internet Protocol"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc793"},"RFC 793"),": Transmission Control Protocol"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc768"},"RFC 768"),": User Datagram Protocol")),(0,r.kt)("h3",{id:"extra-2"},"Extra"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://hpd.gasmi.net"},"Hex Packet Decoder")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.wireshark.org"},"Wireshark")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.kismetwireless.net"},"Kismet")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.ettercap-project.org"},"Ettercap")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://scapy.net"},"Scapy")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://0xbharath.github.io/art-of-packet-crafting-with-scapy"},"The Art of Packet Crafting with Scapy")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.tcpdump.org"},"tcpdump")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.monkey.org/~dugsong/dsniff"},"dsniff")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.devdungeon.com/content/using-libpcap-c"},"Using libpcap in C")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/libnet/nemesis"},"nemesis")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/nmap/nmap"},"nmap"))),(0,r.kt)("h2",{id:"chapter-0x500"},"Chapter 0x500"),(0,r.kt)("p",null,"TODO review"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"exploit_notesearch")," implementation pag 136-150"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tinyweb_exploit")," implementation pag 272-280")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd /share/chapter05\n\n# helloworld\n")),(0,r.kt)("p",null,"Install man pages"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"apt install man-db\n# extra\napt-cache search manpages | egrep 'manpages-(dev|posix)'\n\n# fix \"See 'man 7 undocumented'\"\nyes | unminimize\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Every possible Linux system call is enumerated, so they can be referenced by numbers when making the calls in assembly, See ",(0,r.kt)("inlineCode",{parentName:"li"},"/usr/include/???/unistd.h")),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"mov")," instruction copies a value between its two operands. Using Intel assembly syntax, the first operand is the destination and the second is the source"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"int")," instruction sends an interrupt signal to the kernel, defined by its single operand. With the Linux kernel, interrupt ",(0,r.kt)("inlineCode",{parentName:"li"},"0x80")," is used to tell the kernel to make a system call. When the ",(0,r.kt)("inlineCode",{parentName:"li"},"int 0x80")," instruction is executed, the kernel will make a system call based on the first four registers. The ",(0,r.kt)("inlineCode",{parentName:"li"},"EAX")," register is used to specify which system call to make, while the ",(0,r.kt)("inlineCode",{parentName:"li"},"EBX"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ECX"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"EDX")," registers are used to hold the first, second, and third arguments to the system call. All of these registers can be set using the mov instruction"),(0,r.kt)("li",{parentName:"ul"},"To create an executable ",(0,r.kt)("em",{parentName:"li"},"ELF")," binary, the assembly code must first be assembled and then linked into an executable format"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"nasm")," assembler with the ",(0,r.kt)("inlineCode",{parentName:"li"},"-f elf")," argument will assemble the ",(0,r.kt)("inlineCode",{parentName:"li"},"*.asm")," into an object file ready to be linked as an ELF binary"),(0,r.kt)("li",{parentName:"ul"},"The linker program ",(0,r.kt)("inlineCode",{parentName:"li"},"ld")," will produce an executable ",(0,r.kt)("inlineCode",{parentName:"li"},"*.out")," binary from the assembled object"),(0,r.kt)("li",{parentName:"ul"},"In shellcode",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"instructions must be self-contained and ready to take over control of the processor regardless of its current state"),(0,r.kt)("li",{parentName:"ul"},"the bytes for a string must be mixed together with the bytes for the assembly instructions, since there aren't definable or predictable memory segments"),(0,r.kt)("li",{parentName:"ul"},"to access the string as data we need a pointer to it. When the shellcode gets executed, it could be anywhere in memory. The string's absolute memory address needs to be calculated relative to EIP"))),(0,r.kt)("li",{parentName:"ul"},"Stack-based exploits are made possible by the ",(0,r.kt)("inlineCode",{parentName:"li"},"call")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ret")," instructions. When a function is called, the return address of the next instruction is pushed to the stack, beginning the stack frame. After the function is finished, the ret instruction pops the return address from the stack and jumps EIP back there. By overwriting the stored return address on the stack before the ret instruction, we can take control of a program's execution"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"nasm")," assembler converts assembly language into machine code and a corresponding tool called ",(0,r.kt)("inlineCode",{parentName:"li"},"ndisasm")," converts machine code into assembly")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"apt install nasm -y\n# install hexdump\napt install bsdmainutils -y\n\n# assemble (elf|elf64)\nnasm -f elf helloworld.asm\n# link\nld -m elf_i386 helloworld.o -o helloworld.out\n# run\n./helloworld.out\n\n# hexadecimal view\nhexdump -C helloworld_nosegment.out\n# disassemble\nndisasm -b32 helloworld_nosegment.out\n\nobjdump -D -M intel helloworld.out\nreadelf -a helloworld.out\nstrings helloworld.out\n\n# helloworld\n# helloworld_nosegment\n# helloworld_nonull\n\n# exploit_helloworld.txt\n")),(0,r.kt)("h3",{id:"extra-3"},"Extra"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.nasm.us"},"NASM")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.kernel.org"},"The Linux Kernel Archives")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://linux-kernel-labs.github.io"},"The Linux Kernel Labs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64"},"Linux System Call Table for x86/64")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/38751614/what-are-the-return-values-of-system-calls-in-assembly"},"What are the return values of system calls in Assembly?")),(0,r.kt)("li",{parentName:"ul"},"ITSC 3181 - Lecture 2 ",(0,r.kt)("a",{parentName:"li",href:"https://passlab.github.io/ITSC3181/notes/lecture02_CompilationAssemblingLinkingProgramExecution.pdf"},"Compilation, Assembling, Linking and Program Execution")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://axcheron.github.io/linux-shellcode-101-from-hell-to-shell"},"Linux Shellcode 101: From Hell to Shell"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"TODO pag 295")))}d.isMDXComponent=!0},3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=m(a),d=i,u=h["".concat(l,".").concat(d)]||h[d]||c[d]||r;return a?n.createElement(u,s(s({ref:t},p),{},{components:a})):n.createElement(u,s({ref:t},p))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var m=2;m<r;m++)s[m]=a[m];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},6441:function(e,t,a){t.Z=a.p+"assets/images/memory-segmentation-f4c6d3596df446d5b0c7d6981d5df173.png"}}]);