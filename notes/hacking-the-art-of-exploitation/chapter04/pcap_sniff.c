#include <pcap.h>
#include "../chapter02/hacking.h"

void pcap_fatal(const char *failed_in, const char *errbuf) {
  printf("Fatal Error in %s: %s\n", failed_in, errbuf);
  exit(1);
}

int main() {
  struct pcap_pkthdr header; // contains extra capture information about the packet, such as when it was captured and its length
  const u_char *packet;
  char errbuf[PCAP_ERRBUF_SIZE];
  char *device;
  pcap_t *pcap_handle; // works similarly to a file descriptor, but is used to reference a packet-capturing object
  int i;

  device = pcap_lookupdev(errbuf); // looks for a suitable device to sniff on e.g. /dev/eth0
  if (device == NULL)
    pcap_fatal("pcap_lookupdev", errbuf);

  printf("Sniffing on device %s\n", device);

  // device to sniff, the maximum packet size, a promiscuous flag (1), a timeout value, and a pointer to the error buffer
  pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf); // opens a packet-capturing device
  if (pcap_handle == NULL)
    pcap_fatal("pcap_open_live", errbuf);

  for(i=0; i < 3; i++) {
    // pcap_next() is clumsy and inefficient: prefer pcap_loop()
    packet = pcap_next(pcap_handle, &header); // grab the next packet
    printf("Got a %d byte packet\n", header.len);
    dump(packet, header.len);
  }
  pcap_close(pcap_handle); // closes the capture interface
}

/*

# the pcap libraries must be linked
apt install libpcap-dev
gcc -g pcap_sniff.c -o pcap_sniff.out -l pcap

OUTPUT

# run with sudo or as root
./pcap_sniff.out 
Sniffing on device eth0
...

*/
