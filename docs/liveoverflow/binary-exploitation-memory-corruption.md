---
sidebar_position: 1
id: binary-exploitation-memory-corruption
title: Binary Exploitation / Memory Corruption
---

:::tip About
Short ~10min videos about binary exploitation. From beginner to advanced

[Binary Exploitation / Memory Corruption by LiveOverflow](https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)
:::

## 0x02

### Notes

```bash
docker run --rm -it \
  --name ubuntu \
  -v "$(pwd)/liveoverflow/binary-exploitation-memory-corruption:/share" \
  --platform linux/386 \
  i386/ubuntu:18.04 \
  bash

# install C compiler and debugger
apt-get update && apt-get install vim gcc gdb -y

env
printenv
whereis ls
export PATH=$PATH:/share

cd /share
vim hello.c
:set number

# -Wall enables all warnings
gcc hello.c -o hello.out -Wall
hello.out "liveoverflow"
# prints exit code of previously running program
echo $?

# ELF 32-bit
file hello.out
exiftool hello.out
```

See also `hexdump`, `xxd`, `od`, `hexcurse`, `hexyl`

## 0x03

### Notes

Vim

```bash
cd /share
# split 2 columns
vim -O hello.c hello.py

# change column
CTRL + (double) W
# skip words
CTRL + LEFT/RIGHT ARROW
# jump at the beginning of the line
0
# jump at the end of the line
$
# create new line below cursor
o
# create new line above cursor
SHIFT + o
```

* [Shebang](https://en.wikipedia.org/wiki/Shebang_(Unix))

```bash
python3 hello.py "liveoverflow"

# with shebang
hello.py "liveoverflow"
```

## 0x04

### Resources

* [Embedded Security CTF](https://microcorruption.com)
* [Issue 79, File 0xB](https://sockpuppet.org/issue-79-file-0xb-foxport-hht-hacking.txt.html)

## 0x05

### Notes

Debug

```bash
cd /share
# compile binary
gcc -g -m32 -fno-stack-protector -z execstack -fno-pie -no-pie -Wall license.c -o license.out
license.out AAAA-Z10N-42-OK

# gnu debugger
gdb -q license.out
# every C program has a main function
disassemble main

# default AT&T syntax
# https://visualgdb.com/gdbreference/commands/set_disassembly-flavor
show disassembly-flavor
set disassembly-flavor intel
disassemble main
```

Analysis
```
┌──────────────┐   ┌──────────────┐
│ 497 CMP == 2 │ =2│ 4ad PRINTF   │
│ 49a JNE 4f6  ├───► 4c6 STRCMP   │ returns 0 if equal
└──┬───────────┘   │ 4ce TEST EAX │
   │               │ 4d0 JNE 4e4  │ zeroflag = 0 (strings different)
   │not 2          └─┬──────────┬─┘
   │                 │YES       │NO
┌──▼───────┐ ┌───────▼─────┐ ┌──▼──────────┐
│ 4f6      │ │ 4da PUTS    │ │ 4e4         │
│ 4fe PUTS │ │ 4e2 JMP 506 │ │ 4ec PUTS    │
└──┬───────┘ └───────┬─────┘ │ 4f4 JMP 506 │
   │                 │       └──┬──────────┘
   │            ┌────▼┐         │
   └───────────►│ 506 ◄─────────┘
                └─────┘

Dump of assembler code for function main:
   0x08048486 <+0>:     lea    ecx,[esp+0x4]
   0x0804848a <+4>:     and    esp,0xfffffff0
   0x0804848d <+7>:     push   DWORD PTR [ecx-0x4]
   0x08048490 <+10>:	push   ebp
   0x08048491 <+11>:	mov    ebp,esp
   0x08048493 <+13>:	push   ebx
   0x08048494 <+14>:	push   ecx
   0x08048495 <+15>:	mov    ebx,ecx
   
   # MAIN argc == 2
   0x08048497 <+17>:	cmp    DWORD PTR [ebx],0x2          ; 497 CMP == 2
   0x0804849a <+20>:	jne    0x80484f6 <main+112>         ; 49a JNE to 4f6 (#1)

   0x0804849c <+22>:	mov    eax,DWORD PTR [ebx+0x4]
   0x0804849f <+25>:	add    eax,0x4
   0x080484a2 <+28>:	mov    eax,DWORD PTR [eax]
   0x080484a4 <+30>:	sub    esp,0x8
   0x080484a7 <+33>:	push   eax
   0x080484a8 <+34>:	push   0x80485a0
   # PRINT CHECKING
   0x080484ad <+39>:	call   0x8048330 <printf@plt>       ; 4ad PRINTF
   0x080484b2 <+44>:	add    esp,0x10
   0x080484b5 <+47>:	mov    eax,DWORD PTR [ebx+0x4]
   0x080484b8 <+50>:	add    eax,0x4
   0x080484bb <+53>:	mov    eax,DWORD PTR [eax]
   0x080484bd <+55>:	sub    esp,0x8
   0x080484c0 <+58>:	push   0x80485b6
   0x080484c5 <+63>:	push   eax
   # COMPARE LICENSE
   0x080484c6 <+64>:	call   0x8048320 <strcmp@plt>       ; 4c6 STRCMP returns 0 if equal
   0x080484cb <+69>:	add    esp,0x10
   0x080484ce <+72>:	test   eax,eax                      ; 4ce TEST EAX
   0x080484d0 <+74>:	jne    0x80484e4 <main+94>          ; 4d0 JNE to 4e4 (#2)

   0x080484d2 <+76>:	sub    esp,0xc
   0x080484d5 <+79>:	push   0x80485c6
   # PRINT WRONG
   0x080484da <+84>:	call   0x8048340 <puts@plt>         ; 4da PUTS
   0x080484df <+89>:	add    esp,0x10
   0x080484e2 <+92>:	jmp    0x8048506 <main+128>         ; 4e2 JMP to 506 (#3)

   0x080484e4 <+94>:	sub    esp,0xc                      ; 4e4 (#2)
   0x080484e7 <+97>:	push   0x80485d6
   # PRINT ACCESS
   0x080484ec <+102>:	call   0x8048340 <puts@plt>         ; 4ec PUTS
   0x080484f1 <+107>:	add    esp,0x10
   0x080484f4 <+110>:	jmp    0x8048506 <main+128>         ; 4f4 JMP to 506 (#3)

   # PRINT USAGE
   0x080484f6 <+112>:	sub    esp,0xc                      ; 4f6 (#1)
   0x080484f9 <+115>:	push   0x80485dd
   0x080484fe <+120>:	call   0x8048340 <puts@plt>         ; 4fe PUTS
   0x08048503 <+125>:	add    esp,0x10

   # EXIT
   0x08048506 <+128>:	mov    eax,0x0                      ; 506 (#3)
   0x0804850b <+133>:	lea    esp,[ebp-0x8]
   0x0804850e <+136>:	pop    ecx
   0x0804850f <+137>:	pop    ebx
   0x08048510 <+138>:	pop    ebp
   0x08048511 <+139>:	lea    esp,[ecx-0x4]
   0x08048514 <+142>:	ret    
End of assembler dump.
```

Crack manually

```bash
# step through the program
break main
run

# step into next instruction
si
# step next instruction or ENTER
ni

help
# remove all breakpoints
delete

# >>> hack
break main
# pass invalid key
run MY-KEY
disassemble main
# copy JUMP address of "COMPARE LICENSE"
break *0x080484ce
continue
# check EAX
info registers
# override return value of STRCMP
set $eax=0
```

> TODO 0x06

Reversing and Cracking first simple Program

```bash
# setup
docker run --rm --name reverse -p 5900:5900 -v "$(pwd)/liveoverflow:/share" strawhatsec/reverse

# vnc
vncviewer localhost:5900

# ghidra
docker exec -it reverse bash
ghidra
```

---

* [Smashing the Stack for Fun and Profit](http://insecure.org/stf/smashstack.html)
* [GHIDRA HYPE!! - NSA Reverse Engineering Tool](https://www.youtube.com/watch?v=qtoS3CG6ht0)

Challenges
* [crackmes.one](https://crackmes.one/search)
* archive mirror of [crackmes.de](http://crackmes.cf/archive)
* [exploit.education](https://exploit.education)
    - [exploit-education-solutions](https://github.com/eLoopWoo/exploit-education-solutions)
* [VulnHub](https://www.vulnhub.com) **TODO** on DigitalOcean with Vagrant - no network access

Kernel
* [Intel 64 and IA-32 Architectures Software Developer Manuals](https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html): OPCODE vs SYSCALL
    - [Instruction set reference](https://www.intel.de/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)
* search [kernel](https://elixir.bootlin.com/linux/latest/ident)
* [Searchable Linux Syscall Table for x86 and x86_64](https://filippo.io/linux-syscall-table)
* [Example C to Assembler](https://www.kernel.org/doc/html/latest/x86/exception-tables.html)
* [GDB cheat sheet](https://gist.github.com/rkubik/b96c23bd8ed58333de37f2b8cd052c30)

```bash
file hello
hexdump hello -C
```


* RIP: instrution pointer

Output
```
Dump of assembler code for function main:
   0x0000000000001215 <+0>:	push   rbp
   0x0000000000001216 <+1>:	mov    rbp,rsp
   
   # MAIN
   # from output "break main": (gdb) break main, Breakpoint 1 at 0x1219
   0x0000000000001219 <+4>:	sub    rsp,0x10
   0x000000000000121d <+8>:	mov    DWORD PTR [rbp-0x4],edi
   0x0000000000001220 <+11>:	mov    QWORD PTR [rbp-0x10],rsi
   # argc == 2
   0x0000000000001224 <+15>:	cmp    DWORD PTR [rbp-0x4],0x2
   # (1a)(1b) JUMP NOT EQUAL
   0x0000000000001228 <+19>:	jne    0x1283 <main+110>
   
   0x000000000000122a <+21>:	mov    rax,QWORD PTR [rbp-0x10]
   0x000000000000122e <+25>:	add    rax,0x8
   0x0000000000001232 <+29>:	mov    rax,QWORD PTR [rax]
   0x0000000000001235 <+32>:	mov    rsi,rax
   0x0000000000001238 <+35>:	lea    rdi,[rip+0xdc1]        # 0x2000
   0x000000000000123f <+42>:	mov    eax,0x0
   # (2b) PRINTF CHECKING
   0x0000000000001244 <+47>:	call   0x1020 <printf@plt>
   
   0x0000000000001249 <+52>:	mov    rax,QWORD PTR [rbp-0x10]
   0x000000000000124d <+56>:	add    rax,0x8
   0x0000000000001251 <+60>:	mov    rax,QWORD PTR [rax]
   0x0000000000001254 <+63>:	lea    rsi,[rip+0xdbb]        # 0x2016
   0x000000000000125b <+70>:	mov    rdi,rax
   # (3b)(1c) STRCMP return 0 if equal: man strcmp
   0x000000000000125e <+73>:	call   0x1040 <strcmp@plt>
   # BREAK POINT HERE <<<
   0x0000000000001263 <+78>:	test   eax,eax
   # (4b)(2c) JUMP NOT EQUAL
   0x0000000000001265 <+80>:	jne    0x1275 <main+96>
   
   0x0000000000001267 <+82>:	lea    rdi,[rip+0xdb8]        # 0x2026
   # (5b) PRINTF ACCESS
   0x000000000000126e <+89>:	call   0x1030 <puts@plt>
   0x0000000000001273 <+94>:	jmp    0x128f <main+122>
   
   0x0000000000001275 <+96>:	lea    rdi,[rip+0xdba]        # 0x2036
   # (3c) PRINTF WRONG
   0x000000000000127c <+103>:	call   0x1030 <puts@plt>
   0x0000000000001281 <+108>:	jmp    0x128f <main+122>
   
   # (2a) PRINTF USAGE
   0x0000000000001283 <+110>:	lea    rdi,[rip+0xdb3]        # 0x203d
   0x000000000000128a <+117>:	call   0x1030 <puts@plt>
   # (3a)(6b)(4c) EXIT
   0x000000000000128f <+122>:	mov    eax,0x0
   
   0x0000000000001294 <+127>:	leave  
   0x0000000000001295 <+128>:	ret    
End of assembler dump.
```

```bash
# ascii defines only from 0 to 7F
# 0x7F (0111 1111) = 127 chars
# 0xFF (1111 1111) = 255
# 1 byte goes from 0x00 to 0xFF (0-255)
# - every chars has an assigned number
# - there are numbers that don't have a printable number assigned (weird values in VIM when opening a binary)
man ascii

# all printable chars
strings /share/license

# non-printable chars
hexdump -C /share/license

# disassembly
objdump -d /share/license

man syscall
man syscalls

# trace system calls and signals
strace ./license
ltrace ./license
```

Output
```
strace ./license AAA
execve("./license", ["./license", "AAA"], 0x7ffe79b59438 /* 74 vars */) = 0
brk(NULL)                               = 0x558a8cae4000
arch_prctl(0x3001 /* ARCH_??? */, 0x7fff9fa89ad0) = -1 EINVAL (Invalid argument)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=84800, ...}) = 0
mmap(NULL, 84800, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f5d84687000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360q\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
fstat(3, {st_mode=S_IFREG|0755, st_size=2029224, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f5d84685000
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
mmap(NULL, 2036952, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f5d84493000
mprotect(0x7f5d844b8000, 1847296, PROT_NONE) = 0
mmap(0x7f5d844b8000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x25000) = 0x7f5d844b8000
mmap(0x7f5d84630000, 303104, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19d000) = 0x7f5d84630000
mmap(0x7f5d8467b000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f5d8467b000
mmap(0x7f5d84681000, 13528, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f5d84681000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f5d84686540) = 0
mprotect(0x7f5d8467b000, 12288, PROT_READ) = 0
mprotect(0x558a8c9bb000, 4096, PROT_READ) = 0
mprotect(0x7f5d846c9000, 4096, PROT_READ) = 0
munmap(0x7f5d84687000, 84800)           = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
brk(NULL)                               = 0x558a8cae4000
brk(0x558a8cb05000)                     = 0x558a8cb05000
write(1, "Checking License: AAA\n", 22Checking License: AAA
) = 22
write(1, "WRONG!\n", 7WRONG!
)                 = 7
exit_group(0)                           = ?
+++ exited with 0 +++
```

Radare

> TODO review 0x06

```
r2 license
aaa
s sys.main
pdf
VV
V!
```

Parser differential: program compiles but gdb and radare2 can't

https://www.sentinelone.com/blog/breaking-and-evading
https://ioactive.com/striking-back-gdb-and-ida-debuggers-through-malformed-elf-executables/

Conversions

* Binary Data Structures [struct](https://pymotw.com/3/struct)
* [Endianness](https://en.wikipedia.org/wiki/Endianness)
* [Two's complement](https://en.wikipedia.org/wiki/Two%27s_complement)

```python
# binary to decimal
int('1111', 2)
#15

for i in ["00000000", "00000010", "01010101", "11110010", "11111111"]:
  print("{0} | {1:3} | {2:2x}".format(i, int(i, 2), int(i, 2)))
#00000000 |   0 |  0
#00000010 |   2 |  2
#01010101 |  85 | 55
#11110010 | 242 | f2
#11111111 | 255 | ff

>>> bin(123)
'0b1111011'
>>> hex(123)
'0x7b'
>>> hex(int('0b1111011', 2))
'0x7b'

# I = unsigned integer
```

`setuid` and `setgid`

```
The Unix access rights flags setuid and setgid (short for "set user ID" and "set group ID") allow users to run an executable with the file system permissions of the executable's owner or group respectively and to change behaviour in directories. They are often used to allow users on a computer system to run programs with temporarily elevated privileges in order to perform a specific task.

# example: see `s`
ll /usr/bin/passwd 
Permissions Size User Date Modified Name
.rwsr-xr-x   68k root 28 May  2020  /usr/bin/passwd
```

* 0x0C [video](https://youtu.be/T03idxny9jE)
* [stack0](https://exploit.education/protostar/stack-zero)

```bash
gdb stack0
set disassembly-flavor intel
disassemble main
break main
run
ni
info registers

# map memory
info proc mappings

Mapped address spaces:
          Start Addr           End Addr       Size     Offset objfile
      0x7fffd94cc000     0x7fffd94ed000    0x21000        0x0 [stack]

# stack is bottom-up
# register $ESP points to the top of the stack
# ends to
0x7fffd94cc000
...
# starts from (bottom)
0x7fffd94ed000

# inspect address
x/wx $esp

define hook-stop


# print
python3 -c 'print("A"*64)'
```

```
# >>> ENTER
# register RBP contains ?
0x0000000000001215 <+0>:	push   rbp
0x0000000000001216 <+1>:	mov    rbp,rsp
# mask RSP to keep it nicely aligned ?
0x0000000000001219 <+4>:	sub    rsp,0x70

0x000000000000121d <+8>:	mov    DWORD PTR [rbp-0x64],edi
0x0000000000001220 <+11>:	mov    QWORD PTR [rbp-0x70],rsi
0x0000000000001224 <+15>:	mov    rax,QWORD PTR fs:0x28
0x000000000000122d <+24>:	mov    QWORD PTR [rbp-0x8],rax
0x0000000000001231 <+28>:	xor    eax,eax
0x0000000000001233 <+30>:	mov    DWORD PTR [rbp-0x54],0x0
0x000000000000123a <+37>:	lea    rax,[rbp-0x50]
0x000000000000123e <+41>:	mov    rdi,rax
0x0000000000001241 <+44>:	mov    eax,0x0
0x0000000000001246 <+49>:	call   0x1020 <gets@plt>
0x000000000000124b <+54>:	mov    eax,DWORD PTR [rbp-0x54]
0x000000000000124e <+57>:	test   eax,eax
0x0000000000001250 <+59>:	je     0x1260 <main+75>
0x0000000000001252 <+61>:	lea    rdi,[rip+0xda7]        # 0x2000
0x0000000000001259 <+68>:	call   0x1030 <puts@plt>
0x000000000000125e <+73>:	jmp    0x126c <main+87>
0x0000000000001260 <+75>:	lea    rdi,[rip+0xdc2]        # 0x2029
0x0000000000001267 <+82>:	call   0x1030 <puts@plt>
0x000000000000126c <+87>:	mov    eax,0x0
0x0000000000001271 <+92>:	mov    rdx,QWORD PTR [rbp-0x8]
0x0000000000001275 <+96>:	sub    rdx,QWORD PTR fs:0x28
0x000000000000127e <+105>:	je     0x1285 <main+112>
0x0000000000001280 <+107>:	call   0x1040 <__stack_chk_fail@plt>

# <<< EXIT
# LEAVE—High Level Procedure Exit: Set RSP to RBP, then pop RBP.
# Releases the stack frame set up by an earlier ENTER instruction.
# The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP),
# which releases the stack space allocated to the stack frame.
0x0000000000001285 <+112>:	leave  
0x0000000000001286 <+113>:	ret
```

```
# instruction pointer
EIP
# stack pointer
ESP
# base pointer
EBP

# CALL
# push address after EIP on the stack, then jump to main

# LEA: load effective address
# similar to MOV, instead of moving the content of a register offset into a register,
# it moves the address of register offset into a register 
```

1) before enter main we push address of NEXT function on the stack
2) enter main and we have 2 pointer:
- EBP is at the bottom of the stack frame
- ESP is at the top of the stack frame
- MOV + SUB create space between botto and top
- >>> internal variable are added from the bottom
- >>> parameter are added from the top

https://github.com/NationalSecurityAgency/ghidra/issues/1495
https://github.com/ProtonVPN/linux-cli/issues/297

> TODO 9.10

https://exploit.education/downloads/
