// the machine instructions for the function's code is stored in the text segment
void test_function(int a, int b, int c, int d) {
  // the memory for these variables (a, b, c, d, flag, buffer) is in the stack segment
  int flag;
  char buffer[10];

  flag = 31337;
  buffer[0] = 'A';
}

int main() {
  test_function(1, 2, 3, 4);
}

/*
gcc -g -m32 -fno-stack-protector -z execstack -fno-pie -no-pie stack_example.c -o stack_example.out
gdb -q ./stack_example.out

(gdb) disassemble main
0x0804840a <+0>:	push   ebp                          ; prologue
0x0804840b <+1>:	mov    ebp,esp                      ; prologue
0x0804840d <+3>:	push   0x4                          ; invoke test_function
0x0804840f <+5>:	push   0x3                          ; invoke test_function
0x08048411 <+7>:	push   0x2                          ; invoke test_function
0x08048413 <+9>:	push   0x1                          ; invoke test_function
0x08048415 <+11>:	call   0x80483f6 <test_function>    ; invoke test_function
0x0804841a <+16>:	add    esp,0x10
0x0804841d <+19>:	mov    eax,0x0
0x08048422 <+24>:	leave  
0x08048423 <+25>:	ret
(gdb) disassemble test_function
0x080483f6 <+0>:	push   ebp                          ; prologue
0x080483f7 <+1>:	mov    ebp,esp                      ; prologue
0x080483f9 <+3>:	sub    esp,0x10                     ; prologue
0x080483fc <+6>:	mov    DWORD PTR [ebp-0x4],0x7a69   ; 31337
0x08048403 <+13>:	mov    BYTE PTR [ebp-0xe],0x41      ; A
0x08048407 <+17>:	nop
0x08048408 <+18>:	leave  
0x08048409 <+19>:	ret

- when the `test_function()` is called from the `main()` function,
  the various values are pushed to the stack to create the start of the stack frame
- the function arguments are pushed onto the stack in reverse order: FILO
- when the assembly `call` instruction is executed, the return address is pushed onto the stack
  and the execution flow jumps to the start of `test_function()` at 0x080483f6
- the return address value will be the location of the instruction following the current EIP i.e. 0x0804841a
- the call instruction both stores the return address on the stack and jumps EIP to the beginning of `test_function()`,
  so `test_function()`'s procedure prologue instructions finish building the stack frame:
  * the current value of EBP is pushed to the stack, this value is called the `saved frame pointer` (SFP)
    and is later used to restore EBP back to its original state
  * the current value of ESP is then copied into EBP to set the new frame pointer
  * this frame pointer is used to reference the local variables of the function (`flag` and `buffer`)
  * memory is saved for these variables by subtracting from ESP

# verify with gdb
(gdb) list main
(gdb) break 12
(gdb) break test_function
(gdb) run
(gdb) i r esp ebp eip
esp   0xffaf07a8  0xffaf07a8
ebp   0xffaf07a8  0xffaf07a8
eip   0x804840d   0x804840d <main+3>
(gdb) x/5i $eip
=>  0x804840d <main+3>:   push  0x4
    0x804840f <main+5>:   push  0x3
    0x8048411 <main+7>:   push  0x2
    0x8048413 <main+9>:   push  0x1
    0x8048415 <main+11>:  call  0x80483f6 <test_function>
(gdb) continue
(gdb) i r esp ebp eip
esp   0xffaf0780  0xffaf0780
ebp   0xffaf0790  0xffaf0790
eip   0x80483fc   0x80483fc <test_function+6>
(gdb) print $ebp-0x4
$1 = (void *) 0xffaf078c
(gdb) print $ebp-0xe
$2 = (void *) 0xffaf0782
(gdb) ni
(gdb) ni
(gdb) x/16xw $esp
0xffaf0780:	0x00410001	0xffaf0844	0xffaf084c	0x00007a69  ; ?A? | ??? | ??? | 31337
0xffaf0790:	0xffaf07a8	0x0804841a	0x00000001	0x00000002  ; saved frame pointer (value of EBP in the previous stack frame) | EIP return | 1 | 2
0xffaf07a0:	0x00000003	0x00000004	0x00000000	0xf7d88f21  ; 3 | 4 | ??? | ???
0xffaf07b0:	0x00000001	0xffaf0844	0xffaf084c	0xffaf07d4

# top of STACK FRAME (lower addresses)
buffer
flag
???           ; ebp test_function: `saved frame pointer` (SFP) <<< EBP now points here
0x0804841a    ; `call` pushes the return address and sets EIP=0x080483f6
1
2
3
4
???           ; ebp main
0xffaf07a8    ; bottop of the stack (high addresses)

*/
